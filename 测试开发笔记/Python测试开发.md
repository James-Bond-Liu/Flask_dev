# 基础

## 一、环境管理

### 1、虚拟环境

Python虚拟环境的主要目的是为了给不同的工程创建相互独立的运行环境。在虚拟环境下，每一个工程都有自己的依赖包，而与其他的工程无关。不同虚拟环境中同一个包也可以又不同的版本。可以使用virtualen或者pipenv等工具来创建多个虚拟环境。

### 2、virtualenv管理虚拟环境

#### 1. 使用命令

| 命令                                                   | 注释               |
| ------------------------------------------------------ | ------------------ |
| workon                                                 | 列出所有的虚拟环境 |
| workon  [name]                                         | 进入指定的虚拟环境 |
| deactivate                                             | 退出当前的虚拟环境 |
| mkvirualenv  [name]或者mkvirualenv  -p  python  [name] | 创建虚拟环境       |
| rmvirtualenv  [name]                                   | 删除虚拟环境       |

* 虚拟环境中包的安装

虚拟环境中安装对应的依赖包，进入虚拟环境直接使用pip  install 进行安装（包仅仅存在虚拟环境中，外部环境或者其他虚拟环境上没有包）

* 注意：安装包的时候会把相关的依赖包都安装上，但是卸载的时候依赖包不能卸载

#### 2. requirements.txt文件

requirements.txt文件记录了当前程序的所有依赖包及版本号，其作用是用来在另一个环境上重新构建项目所需要的运行环境依赖。

* pip  freeze  >  requirements.txt  导出当前环境到requirements.txt文件
* pip  install  -r  requirements.txt   使用requirements.txt恢复环境



### 3、pipenv管理虚拟环境

* pipenv 集成了pip，virtualenv两者的功能
* pipenv的命令在各个平台上都是一样的
* pipenv 只能操作当前项目路径下的虚拟环境

#### 1. pipenv创建虚拟环境

1. 创建文件夹	mkdir py3env
2. 进入文件夹    cd  py3env
3. 初始化虚拟环境(创建虚拟环境)  pipenv install

* 创建好虚拟环境后生成：Pipfile文件和Pipfile.lock文件。
* 项目提交时，将Pipfile文件和Pipfile.lock文件一并提交，可供其他开发克隆下载。
* 下载完成放置本地后，在项目路径下，执行pipenv  install  可以根据这两个文件初始化虚拟环境（仅恢复生产部署环境的包）；执行pipevn  install  --dev  可以根据这两个文件初始化虚拟环境（恢复开发环境的包）；

#### 2. pipenv管理模块和包

* pipenv  intall  在当前项目路径下执行，创建虚拟环境。

* pipenv  intall  包名  在虚拟环境中共安装模块或包，注意在当前项目路径下执行以上命令
* pipenv  graph   查看安装包以及依赖关系
* pipenv  uninstall  包名  卸载包同时会把相关的依赖包全部卸载掉。同时从pipfile文件中删除
* pipenv  lock  -r  --cev   >  requirements.txt   生产requirements.txt文件
* pipenv  install  -r  requirements.txt    通过requirements.txt文件安装环境  

#### 3. pipenv的相关使用命令

| 命令                                          | 释义                                                   |
| --------------------------------------------- | ------------------------------------------------------ |
| pipenv  --rm                                  | 删除虚拟环境                                           |
| pipenv  --whree                               | 列出本地工程路径（前提路径下必须有虚拟环境）           |
| pipenv  --venv                                | 列出虚拟环境路径                                       |
| pipenv  --py                                  | 列出虚拟环境的Python可执行文件                         |
| pipenv  graph                                 | 查看包依赖                                             |
| pipenv  lock                                  | 生成lock文件                                           |
| pipenv  shell                                 | 激活虚拟环境                                           |
| exit                                          | 退出虚拟环境                                           |
| pipenv  lock  -r  --cev   >  requirements.txt | 生产requirements.txt文件                               |
| pipenv  install  -r  requirements.txt         | 通过requirements.txt文件安装环境                       |
| pipenv  update                                | 更新所有的包                                           |
| pipenv  update  <包名>                        | 更新指定的包的依赖项                                   |
| pipenv  uninstall  --all                      | 卸载所有包                                             |
| pipenv run python test.py                     | 不激活虚拟环境下使用虚拟环境中的解释器执行 python 程序 |





## 二、Python代码规范

### 1、代码样式规范

1. 行缩进：tap键（4个空格）

   * 对齐缩进

     ```python
     foo = dict(name='liufei',age=26,
                sex='男',height='170')
     ```

     

   * 层级缩进(为了区分应该缩进8格)

     ```python
     def func_add(
     		val1,val2,
         	val3,val4):
         return 423
     ```

     

   * \ ，行连接

     ```python
     with open('test1.txt','w') as f1,\  
          open('test2.txt','w') as f2:
         f1.write("hello")
         f2.write("world")
     ```

2. 单行字符限制

   * 所有行限制的最大字符数位79
   * 没有结构化限制的大块文本（文档字符或者注释），每行最大字符数位72

3. 空行

   * 顶级函数和类的定义之间有两行空行
   * 类顶部的行数定义之间有一行空行

4. 源文件编码方式

   * Python3默认使用UTF-8编码，不再有声明。

5. 注释

   * 行内注释：与代码语句同行的注释。行内注释和代码至少要有两个空格分隔。注释“由#和一个空格开始。”

   * 块注释：快捷键“ctrl+/"，块注释的每一行开头使用一个#和一个空格。块注释内部的段落通过只有一个#的空行来分隔。

   * 文档注释：用三个双引号”“”来包裹注释字符"""

     * 单行文档注释："""注释""",引号和文字在同一行。

     * 多行文档注释：多行文档字符串有一个摘要行组成（开始三引号和摘要行同行）。一行文档字符串，后面跟一行空行，然后再是更加详细的说明，结尾三引号自成一行。

     * 提取文档的注释：对象的\__doc__属性

       ```python
       import requests
       print(requsts.__doc__)
       ```

6. 模块和包相关规范
   * 导入代码位置：位于文件顶部，再文档字符串（注释）之后，再模块的全局变量和常量之前。
   * 导入顺序
     1. 标准库导入
     2. 第三方库导入
     3. 特定的本地应用/库导入

​	

### 2、工程结构化

* 结构介绍：每个工程应该包括什么文件

  | 文件名           | 用途                                                         |
  | ---------------- | ------------------------------------------------------------ |
  | readme           | 对项目的整体介绍，同时也是一份使用手册。通常位README.rst/README.md |
  | LICENSE          | 阐述项目的许可说明和授权                                     |
  | setup.py         | 通过setup把而核心代码打包发布                                |
  | sample           | 存放项目的核心代码                                           |
  | requirements.txt | 存放项目第三方所有依赖的第三方库                             |
  | docs             | 包的参考文档                                                 |
  | tests            | 所有的代码测试都归档存放该目录下                             |
  | makefile         | 用于项目的命令的管理                                         |



## 三、pycharm和git结合使用远程仓库

### 1、基本流程

* 在git上拷贝工程路径，在pycharm上clone项目

  <img src="Python测试开发.assets/image-20210919095142091.png" alt="image-20210919095142091" style="zoom:50%;" />

  <img src="Python测试开发.assets/image-20210919094458316.png" alt="image-20210919094458316" style="zoom: 50%;" />

  <img src="Python测试开发.assets/image-20210919094542393.png" alt="image-20210919094542393" style="zoom:50%;" />

* 后续代码发生改变可以通过右上角直接，pull，commit，push

  ![image-20210919095316307](Python测试开发.assets/image-20210919095316307.png)

### 2、分支

分支，主要涉及多个版本或者多个人开发项目时所能用到的情况。

* 多人开发同一个项目

  * 在push修改到远程之前一定要先从远程pull拉取别人已经修改之后的代码（别人修改的内容会体现在本地仓库中，自己的代码也不会消失）
  * 然后再将代码提交commit、推送push到远程

  

#### 1、在本地创建分支，然后提交到远程

* pycharm右下角创建本地分支

  * 此时创建的分支仅仅存在于本地仓库，远程git仓库并没有这个分支dev2

  <img src="Python测试开发.assets/image-20210919095601285.png" alt="image-20210919095601285" style="zoom:50%;" />

  <img src="Python测试开发.assets/image-20210919095646575.png" alt="image-20210919095646575" style="zoom:50%;" />

  

  

  

* 将本地分支提交到远程仓库

<img src="Python测试开发.assets/image-20210919100110157.png" alt="image-20210919100110157" style="zoom:50%;" />

<img src="Python测试开发.assets/image-20210919100220795.png" alt="image-20210919100220795" style="zoom:50%;" />



#### 2、在dev2分支开发，然后将代码合并merge到主干master上

* master版本的demo2文件

  <img src="Python测试开发.assets/image-20210919100459646.png" alt="image-20210919100459646" style="zoom: 50%;" />

* dev2分支修改demo2文件

  <img src="Python测试开发.assets/image-20210919100636972.png" alt="image-20210919100636972" style="zoom:50%;" />

* 先切换到主干master上

<img src="Python测试开发.assets/image-20210919100906600.png" alt="image-20210919100906600" style="zoom:33%;" />

* 主干master未合并dev2分支的修改前，demo2文件

  <img src="Python测试开发.assets/image-20210919101319405.png" alt="image-20210919101319405" style="zoom:33%;" />

* 在master上将dev2分支的修改合并过来

  <img src="Python测试开发.assets/image-20210919102027277.png" alt="image-20210919102027277" style="zoom:33%;" />

  ![image-20210919101949158](Python测试开发.assets/image-20210919101949158.png)

  <img src="Python测试开发.assets/image-20210919102053281.png" alt="image-20210919102053281" style="zoom: 50%;" />

  

# Python进阶

## 一、数据类型

Python 中的数据类型：

* 数值类型：单个数值
* 序列类型：字符串、列表、元组
* 散列类型：字典、集合（特征：内部元素是无序的）

### 1、元组和列表

1. 元组和列表的性能分析

   计算创建元组和列表所需的时间：ipython  中使用  timeit（元组的性能更好，创建所需的时间更短）

   计算运行代码时间的模块：

   ```python
   import timeit
   
   def func_one():
       for i in range(10):
           print(i)
   
   res1 = timeit.Timer(func_one).timeit(100)  # 方法一：执行这个函数100次用多少时间
   print(res1)
   print("*"*100)
   res2 = timeit.timeit(func_one,number=100)  # 方法二：执行这个函数100次用多少时间
   print(res2)
   ```
   
   

2. 命名元组

   * 普通元组是通过下标索引来取值的，但是有时候是不方便的。有时不知某个元素的具体位置就很难取到具体值。
   * “命名元组”可以通过collections模块中的namedtuple函数来创建一个命名元组类。
   * 命名元组获取元素值类似与获取属性值		


### 2、字典和集合的原理和应用

dict和set的实现原理是一样的，都是将实际的值放到list中，唯一不同的在于hash函数操作的对象，对于dict，hash函数操作的是key，对于set，hash函数直接操作它的元素。

将操作内容放入hash函数，通过运算后取list的余数，转化为list的下标，此下标位置对于set而言用来放其本身，对于dict则是创建了两个list，一个list该小标放key，另一个list中该下标放对应的value。

python的数据类型分为可变类型（不可hash操作）和不可变类型（可hash操作）。

* 不可变数据类型： 当该数据类型的对应变量的值发生了改变，那么它对应的内存地址也会发生改变，对于这种数据类型，就称不可变数据类型。

* 可变数据类型  ：当该数据类型的对应变量的值发生了改变，那么它对应的内存地址不发生改变，对于这种数据类型，就称可变数据类型。

| **数据类型** | **可变/不可变** |
| ------------ | --------------- |
| 整型         | 不可变          |
| 字符串       | 不可变          |
| 元组         | 不可变          |
| 列表         | 可变            |
| 集合         | 可变            |
| 字典         | 可变            |

集合set，只能存放可hash操作的数据类型，比如元组，字符串。

#### 性能分析

* 从时间上比较(查找元素所用时间）：集合 < 字典 < 元组 < 列表
* 占用内存比较：字典 > 集合 > 列表 > 元组

#### 字典查找值的过程

![image-20210706202654250](Python测试开发.assets/image-20210706202654250.png)

### 3、推导式

#### 1. 列表推导式

* 列表推导式是python构建列表list的一种快捷方式，[]

* 实现原理：

  * 列表推导式会先遍历后面的可迭代对象,然后按照for前的表达式进行运算,生成最终的列表.
  * 如果有if条件语句,for遍历后紧跟着进行条件判断.
  * 如果有多个for循环,则最终的数据数量为多个for循环的笛卡尔积.
  * 可以进行嵌套的列表推导,与嵌套for循环的原理相同.

* 生成列表的繁琐方式和列表推导式生成列表比较见代码！

  ```python
  # 繁琐方式
  a = []
  for x in range(10):
  	a.append(x)
  #列表推导式
  a=[x for x in range(10)]
  ```

#### 2. 字典推导式

* 和列表推导式原理是一样的，{}

  ```python
  dict_a = {key: value for key in 'python' for value in range(2)}
  print(dict_a)
  """{'p': 1, 'y': 1, 't': 1, 'h': 1, 'o': 1, 'n': 1}"""
  ```

  

#### 3. 生成器推导式

* 小括号中使用推导式

  

### 4、迭代器和生成器

#### 1. 两者的异同点：

共同点：生成器是一种特殊的迭代器。

不同点：

* 语法上：

  生成器是通过函数的形式中调用 yield 或（）的形式创建的。

  迭代器可以通过 iter（） 内置函数创建。

* 用法上：

  生成器在调用next（）函数或for循环中，所有过程被执行，且返回值。

  迭代器在调用next（）函数或for循环中，所有值被返回，没有其他过程或动作。

#### 2. 可迭代对象

可迭代对象包含迭代器。
如果一个对象拥有__iter__方法，其是可迭代对象；如果一个对象拥有next方法，其是迭代器。
定义可迭代对象，必须实现__iter__方法；定义迭代器，必须实现__iter__和next方法。



![image-20210709101406245](Python测试开发.assets/image-20210709101406245.png)





#### 3. 迭代器（iterator）

* 什么是迭代器

  ​	迭代器是访问可迭代对象的工具
  ​	迭代器是指iter(obj) 函数返回的对象(实例)
  ​	迭代器可以用next(it) 函数获取可迭代对象的数据

* 迭代器函数

  iter(iterable) 从可迭代对象中返回一个迭代器，iterable必须一个能够提供迭代器的对象
  next(iterator) 从迭代器iterator中获取下一个记录，如果无法获取下一条记录，则触发StopIteration异常

* 声明

  迭代器只能往前取值，不会后退

  用iter函数可以返回一个可迭代对象的迭代器



#### 4. yield，send的用法

* return和yield的区别
  * **return：**在程序函数中返回某个值，返回之后函数不在继续执行，彻底结束。
  * **yield:** 带有yield的函数是一个迭代器，函数返回某个值时，会停留在某个位置，返回函数值后，会在前面停留的位置继续执行， 直到程序结束

##### yield用法

* 示例

  ~~~
    def foo():
          print("starting...")
          while True:
              res = yield 4
              print("res:",res)
      g = foo()
      print(next(g))
      print("*"*20)
      print(next(g))
  ~~~

  ~~~
   starting...
      4
      ********************
      res: None
      4
  ~~~

解析：

1.程序开始执行以后，因为foo函数中有yield关键字，所以foo函数并不会真的执行，而是先得到一个生成器g(相当于一个对象)

2.直到调用next方法，foo函数正式开始执行，先执行foo函数中的print方法，然后进入while循环

3.程序遇到yield关键字，然后把yield想象成return,return了一个4之后，程序停止，并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前两行（第一个是while上面的print的结果,第二个是return出的结果）是执行print(next(g))的结果，

4.程序执行print("\*"*20)，输出20个\*

5.又开始执行下面的print(next(g)),这个时候和上面那个差不多，不过不同的是，这个时候是从刚才那个next程序停止的地方开始执行的，也就是要执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是res:None,

6.程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4.

**带yield的函数是一个生成器，而不是一个函数了，这个生成器有一个函数就是next函数，next就相当于“下一步”生成哪个数，这一次的next开始的地方是接着上一次的next停止的地方执行的，所以调用next的时候，生成器并不会从foo函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。**



##### send用法

~~~
 def foo():
        print("starting...")
        while True:
            res = yield 4
            print("res:",res)
    g = foo()
    print(next(g))
    print("*"*20)
    print(g.send(7))
~~~



~~~
 starting...
    4
    ********************
    res: 7
    4
~~~



send函数的概念：send是发送一个参数给res的，yield(return)的时候，并没有把4赋值给res，下次执行的时候只好继续执行赋值操作，只好赋值为None了，而如果用send的话，开始执行的时候，先接着上一次（return 4之后）执行，先把7赋值给了res,然后执行next的作用，遇见下一回的yield，return出结果后结束。

1.程序执行g.send(7)，程序会从yield关键字那一行继续向下运行，send会把7这个值赋值给res变量

2.由于send方法中包含next()方法，所以程序会继续向下运行执行print方法，然后再次进入while循环

3.程序执行再次遇到yield关键字，yield会返回后面的值后，程序再次暂停，直到再次调用next方法或send方法。



#### 5. 生成器（generator）

生成器仅仅保存了一套生成数值的算法，并且没有让这个算法现在就开始执行，而是我什么时候调它，它什么时候开始计算一个新的值，并给你返回。

* 生成器函数

  iter()：

  next()

  send()：发送数据，与生成器交互

  close()：关闭生成器

  throw()：在生成器内部主动引发一个异常

**创建生成器方法一：**

把一个列表生成式的`[]`改成`()`，就创建了一个generator：

```python
L = [x * x for x in range(10)]  # 列表推导式
print(L)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
g = (x * x for x in range(10))  # 生成器（）
print(g)  # <generator object <genexpr> at 0x1022ef630>
```



**创建生成器方法二：**

一个函数中包含`yield`关键字，那么这个函数就不再是一个普通函数，而是一个generator。调用函数就是创建了一个生成器（generator）对象。

```python
def gen():
    for i in range(5):
        print("-----------1-----------")
        se = yield i
        print("----------2----------")
        print(se)
        print("------------3-------")
```









## 二、函数进阶

### 1、子类中调用父类方法

* 父类名.父类方法(self,args1,args2,args3....)

* super().父类方法(args1,args2,args3....)

* 超继承：super(子类名，self).父类方法(args1,agrs2,args3,....)   父类方法中不用传入self实例
* self.父类方法(args1,args2,args3....)

函数/方法中的局部变量不能在该函数/方法之外访问。若要在方法之间共享状态，请使用实例变量

### 2、递归函数

递归函数：在函数内部调用函数自身

递归临界点：满足某个条件后，函数不再调用函数本身。



### 3、纯函数

概念：

* 一个函数的结果只依赖于它的参数，并且执行过程中没有副作用。

原则：

* 变量都只在函数作用域内获得，作为函数参数的传入

* 不会产生副作用，不会改变传入的数据或者其他数据

* 无论何时，相同输入必须保证相同输出

#### 1. 内置函数

python的内置函数属于纯函数：https://docs.python.org/zh-cn/3/library/functions.html

常用的内置函数

* map函数：将可迭代对象中的元素遍历，传入第一个参数（函数）中调用，将返回结果存储到返回的map对象中。

* filter函数：过滤函数。filter(function, iterable)**相当于一个生成器表达式**，当 function 不是 `None` 的时候为 (item for item in iterable if function(item))

* zip函数：接收多个可迭代的参数，返回一个map对象。将第一个参数的第一个元素和第二个参数的第一个元素取出来,打包成一个元组.同理后续相同操作.

### 4、匿名函数

定义函数：1、def 函数名(参数) 2、lambda  参数1，参数2:函数内部return内容

适用场景：简单的函数定义（只有一个表达式）**lambda 参数：表达式**(返回值)

```python
def func(a,b):
	retrun a+b
# 匿名函数
lambda a,b:a+b
# 函数调用一
res = lambda a,b:a+b
print(res(1,2))
# 函数调用二，即用即释放
(lambda a,b:a+b)(1,2)
```



### 5、偏函数	(partial)

利用python的内置模块functools.partial，创建偏函数

作用：当函数的参数太多时，需要简化时，创建一个偏函数，可以固定原函数的部分参数，从而使调用函数变得更加简单。

### 6、闭包

通俗理解

* 一般情况下，在我们认知当中，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。

一个完整的闭包必须满足下面三个条件

* 函数之中嵌套另一个函数

* 外层函数返回内层函数的变量名

* 内层函数有引用外层函数的非全局变量。内层函数不能引用全局变量。
* ![image-20210711194011449](Python测试开发.assets/image-20210711194011449.png)

闭包作用

* 最主要的目的是为装饰器服务

### 7、装饰器

#### 定义

开放封闭原则：软件实体的的功能是可以扩展的，但是函数实体不能修改。

装饰器的作用：在不更改原功能函数内部代码，并且不改变调用方法的情况下为原函数添加新功能。

应用场景：登录验证；函数运行时间；执行函数之前的准备工作；执行函数后清理功能；插入日志、性能测试、事务处理、权限校验

* 实质： 是一个函数

* 参数：是你要装饰的函数名（并**非函数调用**）

* 返回：是装饰完的函数名（也**非函数调用**）

* 作用：为已经存在的对象添加额外的功能

* 特点：不需要对对象做任何的代码上的变动

![image-20210724124247525](Python测试开发.assets/image-20210724124247525.png)

注意：

* 装饰器装饰类时，装饰器内层函数一定要return 返回内层函数，否则无法调用类时无法创建实例对象。
* 装饰器装饰函数且被装饰函数有返回值（被装饰函数有return）时，装饰器内层函数也一定要return返回内层函数，否则，被装饰函数无法返回值。

#### Python中的三种内置装饰器

* @classmethod：不可以调用类中的属性，需要参数必须在自己函数中传入，类不用实例化就可直接调用方法（实例对象可以正常调用）
* @property： 将某函数，做为属性使用 ，且这个属性不可以更改。
* @staticmethod：不可以调用类中的属性，需要参数必须在自己函数中传入，类不用实例化就可直接调用方法（实例对象可以正常调用）

#### 装饰器调用方式

显性调用

~~~python
import time
def decorator(fun):
    def wrapper():
        print(time.time())	##打印linux系统时间，从1970年1月1日开始计算时间
        fun()
    return wrapper

def f1():
    print('This is a function')

f = decorator(f1)	##调用装饰器方式一，写在函数后面。把函数体当作参数传给装饰器函数，然后再调用被装饰函数本身。
f()
~~~

隐性调用

~~~python
import time
def decorator(fun):
    def wrapper():
        print(time.time())
        fun()
    return wrapper
@decorator	##调用装饰器方式二，写在函数前面。等价于decorator（f1）（）
def f1():
    print('This is a function')
f1()

~~~



## 三、面向对象之魔术方法

定义：在Python中，所有以“__”双下划线包起来的方法，都统称为“Magic Method”.（\_\_init\_\_或 \_\_new\_\_等)。<u>魔术方法是在类中声明 .定义的方法 , 执行时无需手工调用 ,自动触发执行</u>

一个最基本的魔术方法，\_\_init\_\_。通过此方法可以对一个类进行实例化的操作。然而，当调用例如 x = SomeClass() 进行实例化类时， \_\_init\_\_并不是第一个被调用的方法。实际上，还有一个叫做new 的方法，两个共同构成了“构造函数”。\_\_new\_\_是用来创建类并返回这个类的实例, 而init只是将传入的参数来初始化该实例。

### 1、\_\_new_\_方法

- 触发时机：实例化类生成对象的时候触发(触发时机在__init__之前)
- 功能：控制对象的创建过程
- 参数:至少一个cls接受当前的类,其他根据情况决定
- 返回值：通常返回对象或None



### 2、单例模式（利用重写\_\_new\_\_方法实现）

一般情况下，类每次实例化的时候都会创建一个新的对象。但是要求类实例化的时候只能创建一个对象，当第二次、第三次实例化类的时候，均返回第一次实例化的对象。

 

### 3、\_\_str\_\_方法和\_\_repr\_\_方法

当我们打印或查看某个对象时，最终看到的结果是这两个方法的返回值。这两个方法返回的都是字符串

```shell
>>> a='panda'
>>> print(a)
panda
>>> a
'panda'
# 交互环境下，打印变量和直接输入变量，返回的内容不一样
```

* 使用print打印触发的是\_\_str\_\_方法，~~打印的内容实际为\_\_str\_\_方法返回的内容~~

* 交互环境下直接输入变量触发的是\_\_repr\_\_方法

![image-20210725152439061](Python测试开发.assets/image-20210725152439061.png)

总结：

* str()和repr()函数都是将任意输入的对象转化为字符串，函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式。
* 使用str函数或者print打印对象时会优先触发str方法，没定义\_\_str\_\_方法的情况下，会再去找\_\_repr\_\_方法，如果都没有，则回去找父类中的\_\_str\_\_方法
* 使用repr函数或者交互环境下输入变量对象，会先找自身的\_\_repr\_\_方法，自身没有\_\_repr\_\_方法，会再去找父类的\_\_repr\_\_方法。

两者的区别：
\_\_str\_\_是一个对象的非正式的、易于阅读的字符串描述，当类str实例化（ str(object) ）时会被调用，以及会被内置函数format()和print()调用；\_\_repr\_\_是一个对象的官方的字符串描述，会被内置函数repr()方法调用，它的描述必须是信息丰富的和明确的。也就是说\_\_str\_\_返回的结果可读性强，\_\_repr\_\_返回的结果更加准确

重写：

重写\_\_str\_\_方法和\_\_repr\_\_方法时，必须写return，且 return返回的必须是一个字符串



### 4、\_\_call\_\_方法

触发时机：把对象当作函数调用的时候自动触发

功能: 模拟函数化操作

参数: 参数不固定,至少一个self参数

返回值: 看需求

python中万物皆对象，函数也是对象，如何能让其他对象像函数一样可以被调用，只需要重写一下\_\_call\_\_方法





### 5、上下文管理器

 思考：with打开文件为什么会自动关闭文件

 概念：上下文管理器是一个python对象，为操作提供了额外的上下文信息。任何实现了 \_\_enter \_\_() 和 \_\_ exit() \_\_ 方法的对象都可称之为上下文管理器，上下文管理器对象可以使用 with 关键字。

上下文管理器中有\_\_enter \_\_() 和 \_\_ exit() \_\_  两个方法，以with为例子，__ \_\_ enter() \_\_ __ 方法会在执行 with 后面的语句（<u>open()</u>）时执行，一般用来处理操作前的内容。比如一些创建对象，初始化等； \_\_ exit() \_\_ 方法会在 with 内的代码执行完毕后执行，一般用来处理一些善后收尾工作，比如文件的关闭，数据库的关闭等。

**with的执行原理:**

实际上，在文件操作时，并不是不需要写文件的关闭，而是文件的关闭操作在 with 的上下文管理器中的协议方法里已经写好了。当文件操作执行完成后， with语句会自动调用上下文管理器里的关闭语句来关闭文件资源。

**with的执行过程：**

在执行 with 语句时，首先执行 with 后面的 open 代码，执行完代码后，会将open代码的结果通过 as 保存到 f 中。然后在下面实现真正要执行的操作，在执行完操作后，并不需要写文件的关闭操作，文件会在使用完后自动关闭

~~~
with context_expr [as var]:
    with_body
~~~

1. 执行上下文表达式(context_expr)以获得上下文管理器对象。
2. 加载上下文管理器对象的`__exit__()`方法，备用。
3. 执行上下文管理器对象的`__enter__()`方法。
4. 如果有`as var`语句，将`__enter__()`方法返回值绑定到 as 后面的 变量中。
5. 执行 with 内的代码块(with_body)。
6. 执行上下文管理器的__exit__()方法



#### 自定义类实现上下文管理器

~~~
class OpenFile(object):
    def __init__(self, filename):
        self.file = open(filename, 'w+')
 
    def __enter__(self):
        return self.file
 
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.file.close()
 
 
def main():
    with OpenFile('text.txt') as f:
        f.write('ok')
 
        
if __name__ == "__main__":
    main()
~~~



#### contextilb模块实现上下文管理器

**@contextmanager**，这是contextlib模块提供的一个装饰器，用于将一个函数声明上下文管理，无需创建一个类或者单独的`__enter__()`方法和`__exit__()`方法，就可以实现上下文管理。

需要注意的是，被装饰的函数被调用的时候必须返回一个生成器，而且这个生成器只生成一个值，如果有as的话，该值讲绑定到with语句as子句的目标中。

~~~
from contextlib import contextmanager
 
 
@contextmanager
def tag(name):
    print('<{}>'.format(name))
    yield
    print('</{}>'.format(name))
 
 
with tag('title'):
    print("This is a contextmanger test")
~~~



~~~
<title>
This is a contextmanger test
</title>
~~~

输出流程：

1. 先输出`yield`前的输出语句；（相当于enter）
2. 然后再是`tag()`函数的输出语句，
3. 最后是`yield`**后面的输出语句**（相当于exit)





### 6、算术运算

思考：python中不仅数值之间能相加，字符串、列表、元组之间也能进行，怎么实现？

同类型对象之间使用+的时候，实际上是触发了\__add\_\_魔术方法。

其他算数运算符对应的魔术方法：

 \_\_ add \_\_(self, other)			定义加法的行为 +

 \_\_ sub \_\_ (self, other)			定义减法的行为 -

 \_\_ mul \_\_ (self, other)			定义乘法的行为 *

 \_\_ truediv\_\_ (self, other)		定义真除法的行为 /

 \_\_ floordiv\_\_ (self, other)       定义整数除法的行为 //

 \_\_ mod \_\_ (self, other)			定义取余法的行为  %





### 7、多态

#### 1. 面向对象三大特征

* 封装：将数据和方法放在一个类中就构成了封装
* 继承：python中一个类可以继承于一个类也可以继承多个类。
* 多态：指的是一类事物有多种形态，一个抽象类有多个子类（所以多态依赖于继承），不同的子类对象调用相同的方法，产生不同的执行结果。

#### 2. 多态

**多态实际上就是<u>继承</u>**

实现多态的步骤

* 定义一个父类，实现某个方法（比如run）

* 定义多个子类，在子类中重写父类的方法（run），每个子类run方法实现不同的功能。
* 定义一个函数，调用函数的时候传入不同的子类对象，那么这个函数就会调用不同子类的run方法，执行不同的功能，这个就是多态。

多态的意义：开放封闭原则

* 当需要新增功能，只需要新增一个Base的子类实现run()方法，就可以在原来的基础上进行功能扩展
* 对扩展开放：允许新增Base子类
* 修改封闭：不需要修改依赖Base类型的run()等函数。

### 8、数据和自省

#### 1. 私有属性

类里面定义的变量叫做属性，分为共有属性和私有属性。

私有属性的定义

* 单下划线开头：`_attr`,对外公开，在类外部可以直接访问
* 双下划线开头：`__attr`，在类外部不能直接访问，为保护这个变量，双下划线开头的私有属性对外被python改名了，改为，`_类名__attr`，所以在外部就不能直接访问原名了。

#### 2. `__dict__`

类调用`__dict__`属性，返回类属性和方法的字典(包括静态函数、类函数、普通函数、全局变量)

实例对象调用`__dict__`属性，返回对象的属性和方法，主要存储了一些实例变量self.***

默认情况下，类的实例有一个字典用来存储属性，这对于具有很少实例变量的对象会很浪费空间。

#### 4. `__slots`

通过在类定义中定义`__slots__`来覆盖默认的`__dict__`行为。`__slots__`声明接受一个实例变量序列。当一个类需要创建大量实例时，可以通过`__slots__`声明实例所需要的属性，它的作用是阻止在实例化类时为实例分配`__dict__`，但是类本身还是分配`__dict__`

作用：更快的属性访问速度，减少内存消耗

#### 5. 自定义属性访问

`__getattribute__`方法：当对象访问类中的属性的时候，第一时间触发这个方法去寻找属性

`__getattr__`方法：当对象访问类中某属性不存在的时候（报错 AttrError），会自动触发这个方法。官方解释此方法应该返回一个找到的属性值或者引发一个异常（可以调用父类object类方法引发异常）。

`__setattr__`方法：当给对象设置属性的时候会触发这个方法

`__delattr__`方法：当给对象删除属性的时候会触发这个方法。删除对象属性的方法：**del 对象名.属性名**





#### 6. 描述器

描述器（descriptor）是一个有”绑定行为”的对象属性（object attribute），它的属性访问被描述器协议方法重写。这些方法是`__get__()`、 `__set__()` 和 `__delete__()` 。如果一个对象定义了以上任意一个方法，它就是一个描述器。

描述器本质上是一个类对象，该对象定义了描述器协议三种方法中至少一种。

描述器必须出现在所有者类之内才有效。这里说的两个类，一是定义了描述器协议的描述器类，另一个是使用描述器的所有者类。



#### 7. ORM模型介绍

**ORM概念**：对象关系映射模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。

ORM解决的主要问题是对象和关系的映射,它通常将一个类和一张表一一对应,类的每个对象对应表中的一条记录,类的每个属性对应表中的每个字段。ORM提供了对数据库的映射,不用直接编写SQL代码,只需操作对象就能对数据库的数据进行操作.让开发人员专注于业务逻辑的处理,提高了开发效率。

* O(objects)：类和对象

* R(Relation)：关系，关系数据库中的表格

* M(Mapping)：映射

![image-20210802210132488](Python测试开发.assets/image-20210802210132488.png)



**劣势：**ORM的操作是有限的，也就是ORM定义好的操作是可以完成的，一些复杂的查询操作是完成不了。不能建数据库和删除数据库。

**ORM框架的功能**

* 建立模型类和表之间的对应关系，允许我们通过面向对象的方式来操作数据库
* 根据设计的模型类生成数据库中的表格
* 通过方便的配置就可以进行数据库的切换

**ORM总结**
ORM只是一种工具，工具确实能解决一些重复，简单的劳动,但我们不能指望某个工具能一劳永逸地解决所有问题，一些特殊问题还是需要特殊处理的。但是在整个软件开发过程中需要特殊处理的情况应该都是很少的，否则所谓的工具也就失去了它存在的意义。

**数据库的字段类型**

* mysql的常用数据类型

  整数：int，bit

  小数：decimal

  字符串：varchar，char

  日期时间：date，time，datetime

  枚举类型：enum

* ORM模型中对应的字段（下面为django的ORM模型中选取的几个字段）

| 类型                           | 描述                                   |
| ------------------------------ | -------------------------------------- |
| BooleanField                   | 布尔字段                               |
| CharField(max_length=最大长度) | 字符串。参数max_length表示最大字符个数 |
| IntegerField                   | 整数                                   |



### 9、元类（type）

资料：https://www.cnblogs.com/tkqasn/p/6524879.html

**旧式类：**类继承instance类型（python2）

**新式类：**类继承object类型（python3）



<u>type</u>：python3中所有的类都是通过type（元类）来创建出来的

<u>object</u>：python3中所有类的顶级父类都是object

![image-20210805205119216](Python测试开发.assets/image-20210805205119216.png)

函数type实际上是一个元类。type就是Python在背后用来创建所有类的元类。str是用来创建字符串对象的类，而int是用来创建整数对象的类。type就是创建类对象的类。你可以通过检查`__class__`属性来看到这一点。Python中所有的东西，注意，我是指所有的东西——都是对象。这包括整数、字符串、函数以及类。它们全部都是对象，而且它们都是从一个类创建而来。



Python中的类也是对象。它的本质仍然是一个对象，元类就是用来创建这些类（对象）的，元类就是类的类。

```python
MyClass = MetaClass()    #通过元类创建类
MyObject = MyClass()     #通过类创建实例
实际上MyClass就是通过type()来创创建出MyClass类，它是type()类的一个实例；同时MyClass本身也是类，也可以创建出自己的实例，这里就是MyObject
```



#### 1. 动态的创建类

**type的语法**

```python
type(类名, 父类的元组（针对继承的情况，可以为空），包含属性、方法的字典（名称和值）)
```



```python
# 1、构建Foo类
class Foo(object):
    bar = True

# 使用type动态的构建（底层就是以type创建的类）
Foo = type('Foo', (), {'bar': True})

# 2、继承Foo类
class FooChild(Foo):
    pass

# 使用type构建
FooChild = type('FooChild', (Foo,), {})
```



#### 2. 自定义元类

* 自定义元类必须继承于type元类，只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类，自定义元类可以控制类的产生过程，类的产生过程其实就是元类的调用过程。

* metaclass参数：在使用class创建类的时候，可以通过在类定义的行传递metaclass关键字参数来指定创建类的元类
* 默认的方式创建类：没有指定的情况下使用默认元类type进行创建



**类的创建过程分析**

* 类的创建过程可以通过在定义metaclass关键字参数来指定创建类的元类
  * 如果python没有找到metaclass，它会继续在父类中寻找metaclass，并尝试做和前面同样的操作，如果python在任何父类都找不到metaclass，python就会用内置的type来创建这个类对象

#### 3、ORM模型实现原理（元类）

ORM模型底层就是用元类构建的。

实现技术点分析

* 类对应表，创建类的时候需要自动生成对应的数据表

* 对象对应一条数据，创建一个对象，需要在数据表中添加一条数据

* 属性对应字段，修改对象属性的同时需要修改数据库中对应的字段

## 四、内存管理

#### 1、对象引用

```python
>>> a = [1, 2]
>>> b = a
>>> id(a)
1633732497728
>>> id(b)
1633732497728
>>>
```

* a和b的地址是一样的，b只是指向了a的地址

#### 2、小整数池

Python自动将`-5-256`的整数进行了缓存放在小整数池中，当将这些整数赋值给变量时，并不会重新创建对象，而是使用已经创建好的缓存对象。所以如下，a和b的内存地址是完全一样的

```python
In [1]: a = 10

In [2]: b = 10

In [3]: id(a)
Out[3]: 140734467852224

In [4]: id(b)
Out[4]: 140734467852224
```

#### 3、字符串驻留池（intern机制）

python会将一定规则的字符串在<u>字符串驻留池</u>中创建一份，当你将这些字符串赋值给变量时，并不会重新创建对象，而是在使用字符串驻留池中创建好的对象。注意一定规则的字符串是指字母、数字、下划线组成的字符串。当字符串中出现特殊字符时，不保存在字符串驻留池里。



```
In [1]: s1 = 'ad12_'

In [2]: s2 = 'ad12_'

In [3]: id(s1)
Out[3]: 2278745662320

In [4]: id(s2)
Out[4]: 2278745662320

In [5]: s3 = '@2'

In [6]: s4 = '@2'

In [7]: id(s3)
Out[7]: 2278757955888

In [8]: id(s4)
Out[8]: 2278756930160
```





#### 4、深浅拷贝

深浅拷贝主要在列表嵌套列表时讨论

**浅拷贝**

拷贝对象的引用

![image-20210807193409297](Python测试开发.assets/image-20210807193409297.png)



**深拷贝**

直接拷贝内容

![image-20210807193826222](Python测试开发.assets/image-20210807193826222.png)



#### 5、垃圾回收和GC机制

**垃圾回收**

1. 引用计数
   Python垃圾回收主要以引用计数为主，分代回收为辅。引用计数法的原理是每个对象维护一个ob_ref，用来记录当前对象被引用的次数，也就是来追踪到底有多少引用指向了这个对象。

   当发生以下四种情况的时候，该对象的引用计数器+1

   * 对象被创建  a=14
   * 对象被引用  b=a
   * 对象被作为参数,传到函数中   func(a)
   * 对象作为一个元素，存储在容器中   List={a,”a”,”b”,2}

   

   与上述情况相对应，当发生以下四种情况时，该对象的引用计数器-1。指向该对象的内存的引用计数器为0的时候，该内存将会被Python虚拟机销毁

   * 当该对象的别名被显式销毁时  del a
   * 当该对象的引别名被赋予新的对象，   a=26
   * 一个对象离开它的作用域，例如 func函数执行完毕时，函数里面的局部变量的引用计数器就会减一（但是全局变量不会）
   * 将该元素从容器中删除时，或者容器被销毁时。
   
   
   
   **标记清除**
   
   『标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。
   
   
   
   **分代回收**
   
   分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象

## 五、并发和性能

### 1、并发和并行

#### **1. 多任务**

概念：操作系统可以同时执行多个任务

CPU和多任务的关系

* 单核CPU是否可以执行多任务？
  * 也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3执行0.01秒…这样反复执行下去，表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。

* 真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行

#### **2. 并发和并行**

* 并发：指的是任务数多于CPU核数，通过操作系统的各种任务调度算法，实现用多个任务”一起"执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）
* 并行：指的是任务数小于等于cpu核数，即任务真的是一起执行的

#### **3. 同步和异步**

* 同步（同步协调）：是指线程在访问某一资源时，获得了资源的返回结果之后才会执行其他操作（先做某件事，再做某件事），
* 异步：与同步相对，是指线程在访间某一资源时，无论是否取得返回结果，都进行下一步操作；当有了资源返回结果时，系统自会通知线程，执行相关操作。
  * 提交注册数据----校验数据----注册成功---登陆，校验校验数据之后即发送账号激活---邮件激活，两者同时发生，不用的等待注册总流程跑完再进行激活

### 2、线程

理解多线程：打开一个QQ为一个进程，打开多个聊天窗口和多人聊天就是多线程。



#### **1. threading模块介绍**

python的 thread模块是比较底层的模块， python的 threading模块是对 thread做了一些包装的，可以更加方便的被使用

* 创建线程对象：threading.Thread（ target=func）
* 参数 target指定线程执行的任务（函数）



Thread类提供了以下方法方法:

| 方法         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| run()        | 用以表示线程活动的方法（执行线程的target目标方法）           |
| start()      | 启动线程活动（start启动线程，run执行target目标方法）         |
| join([time]) | 设置主线程会等待tme秒后再往下执行，time不传默认为子线程结束，多个子线程之间设置的值会叠加 |
| isAlive()    | 返回线程是否活动的                                           |
| getName()    | 返回线程名                                                   |
| setName()    | 设置线程名                                                   |

* threading. current_thread()：返回当前执行的线程。
* threading.enumerate()：返回正在运行的所有线程（list），正在运行是指线程启动后、结束前，不包括启动前和终止后的线程。
* threading. activeCount()：返回正在运行的线程数量



#### **2. 多线程实现多任务**

* 利用Thread类实现多线程多任务

  join()方法：主线程默认是不会等待子线程，子线程执行子线程的任务，主线程执行主线程的任务。 join方法可以设置主线程等待的时间，多个子线程同时使用join设置的时间会叠加

* 利用继承Thread类来创建线程

  将线程的相关操作重写在run方法内部

##### **1. 多线程-共享全局变量**

1、多线程之间修改全局变量

* 线程之间是共用同一块内存的，那么线程可以共享全局变量

案例：当前有一个全局变量a=100，再线程a中修改，线程b中是否会生效

**总结**

* 在一个进程内的所有线程共享全局变量，很方便在多个线程间共享数据

* 缺点就是，线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全）



2、多线程-共享全局变量的问题

* 如果多个线程同时对同一个全局变量操作，会出现资源竞争问题，从而数据结果会不正确
* 当有多个线程的时候，经常需要去这些线程以访问同一个数据或资源。例如，假设有一个程序，其中一个线程用于把文件读到内存，而另一个线程用于统计文件中的字符数。当然，在把整个文件调入内存之前，统计它的计数是没有意义的。但是，由于每个操作都有自己的线程，操作系统会把两个线程当作是互不相干的任务分别执行，这样就可能在没有把整个文件装入内存时统计字数。为解决此问题，你必须使两个线程同步工作。



##### **2. 同步&互斥锁**

* 上面的bug如何解决？——控制线程的执行，避免同时获取数据

**同步**

同步就是协同步调，按预定的先后次序进行运行。“同"字从字面上容易理解为一起动作，其实不是，"同字应是指协同、协助、互相配合。如进程、线程同步，可理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行；B执行，再将结果给A，A再继续操作。

**互斥锁**

互斥：用对资源的访问来定义的话，互斥某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。

线程同步能够保证多个线程安全访向竞争资源，最简单的同步机制是引入互斥锁。

互斥锁为资源引入一个状态：锁定/非锁定

某个线程要更改共享数据时，先将其锁定，此时资源的状态为"锁定"，其他线程不能更改直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源

互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性



threading模块定义了Lock类，可以方便的处理锁定

创建锁：mutex = threading.Lock()

锁定：mutex. acquire()

释放：mutex. release()



注意：
如果这个锁之前是没有上锁的，那么 acquire不会堵塞。如果在调用 acquire对这个锁上锁之前它已经被其他线程上了锁，那么此时 acquire会堵塞，直到这个锁被解锁为止——死锁。

**死锁**

在线程间共享多个资源的时候，如果两个线程分别占有一部分资源井且同时等待对方的资源，就会造成死锁。尽管死锁很少发生，但一旦发生就会造成应用的停止响应。





##### **3. GIL全局解释器锁（扩展）**

Python全局解释器锁（GIL）是一种互斥锁（或锁），仅允许一个线程持有Python解释器的控制权。GIL只在CPython解释器上存在。这意味着在任何时间点只能有一个线程处于执行状态。GIL锁的作用就是来保证整个程序中同时只能有一个程序在运行。只能利用一个CPU。

GIL的作用与互斥锁的作用相似，是为了解决解释器中多个线程资源竞争的问题。

**互斥锁和GIL的区别**

线程互斥锁是Python代码层面的锁，解决我们自己写的Python程序中多线程共享资源的问题。

GIL是Python解释器层面的锁，解决解释器中多个线程的竞争资源问题。

**GIL对程序的影响**

1.Python中的多线程被称为“伪多线程”，因为无论如何，都逃不过GIL解释器锁。

2.因为GIL的存在，在Python中同一时刻有且只有一个线程会执行，只能并发不能并行。

3.因为线程是存在于进程中的，线程是CPU调度和分派的基本单位，Python中的多线程由于GIL锁的存在无法利用多核 CPU。

4.GIL在程序中有IO操作时才切换到其他线程，所以Python中的多线程不适合计算密集型的程序，只适合IO密集型的程序。

**问题： python单线程和多线程分别来完成工作，到底哪个快**？

IO密集型：涉及到网络、磁盘o的任务都是IO密集型任务，这类任务的特点是cPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO操作的速度远远低于CPU和内存的速度）——多线程

CPU密集型：CPU密集型也称为计算密集型，任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。——单线程

线程释放GIL锁的情况：第一，在IO操作等可能会引起阻塞的 system call 之前可以暂时释放GIL，但在执行完毕后必须重新获取 GIL 。第二，Python3x使用计时器（执行时间达到阈值后，当前线程释放GIL）或 Python2x, tickets计数达到100



### 3、队列

Python的 queue.Queue()模块中提供了同步的、线程安全的队列类，包括：先入先出队列 Queue、 后入先出队列LifoQueue 、优先级队列 PriorityQueue，这些队列都实现了锁原语，能够在多线程中直接使用。可以使用队列来实现线程间的同步。
初始化 Queue()对象时（例如：q= Queue())，若括号中没有指定最大可接收的消息数量，或数量为负值那么就代表可接受的消息数量没有上限。

#### 1. 队列方法：

​	def task_done (self):  ...在完成一项工作之后，使用 Queue. task_done()方法可以向队列发送一个信号，表示该任务执行完毕

* 注意点：join()判断的依据，不单单指的是队列中没有数据，数据get出去之后，要使用task done（向队列发送一个信号，表示该任务执行（数据使用）完毕，然后再往下执行。

​	def join (self):  ...实际上意味着等到队列中所有的任务（数据）执行完毕之后，再往下，否则一直等待

​	def qsize(self):  ...返回当前队列包含的消息数量

​	def empty(self):  ...如果队列为空，返回True，反之 False 

​	def full(self):  ...如果队列满了，返回Tue，反之Fase

​	def put(self, item, block=True, timeout=None):  ...写入队列，block表示是否等待，如果 timeout表示是否等待

​	def get(self, block=True, timeout=None ):  ...获取队列， timeout等待时间。block表示是否等待，如果 timeout表示是否等待

​	def put_ nowait(self, item):  ...不用等待队列中是否有位置直接添加，无位置则报错。相当于q.pu(item, block=False)

​	def get_nowait(self):  ...不用等待直接取出，如果没有则报错。相当于q.get(block=False)

#### 2. 多线程与队列

* 队列queue是安全的，从多个线程访问队列时不用加锁。

* 队列线程的思想： 首先创建一个全局共享的队列，队列中只存在有限个元素，并将所有的数据逐条加入到队列中，并调用队列的join函数进行等待。之后便可以开启若干线程，线程的任务就是不断的从队列中取数据进行处理就可以了。
* 类似于生产者和消费者的关系，生产者线程生产数据保存到队列中，消费者线程从队列获取数据处理。



### 4、进程

* https://www.cnblogs.com/jiangfan95/p/11439207.html
  * 基础普及

#### 1. 进程

* 什么是进程
  * 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。
  * 程序：例如xxx.py这个就是程序，是一个静态的
  * 一个程序运行起来后，代码+用到的资源称之为进程，它是操作系统分配资源的基本单元。
  * 不仅可以通过线程完成多任务，进程也是可以的
* 进程的状态
  * 工作中，任务数往往大于cpu的核数，即一定有一些任务正在执行，而另外一些任务在等待cpu进行执行，因此导致了有了不同的状态
  * 就绪状态：运行的条件都已经满足了，正在等在cpu执行
  * 执行状态：cpu正在执行其功能
  * 等待状态：等待某些条件满足，例如一个程序 sleep了，此时就处于等待态

#### 2. 进程、线程对比

* 功能
  * 进程，能够完成多任务，比如在一台电脑上能够同时运行多个软件
  * 线程，能够完成多任务，比如一个QQ中的多个聊天窗口
* 定义的不同
  * 进程是系统进行资源分配和调度的一个独立单位
  * 线程是进程的一个实体，是CPU调度和分派的基本单位。它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器一组寄存器和栈）但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源
* 区别
  * 一个程序至少有一个进程，一个进程至少有一个线程
  * 线程的划分尺度小于进程（资源比进程少），使得多线程程序的并发性高

* 优缺点
  * 线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反

#### 3. multiprocessing模块

* Process(group=None[, target=None, name=None, args=(), kwargs={}, *, daemon=None])
  * target：如果传递了函数的引用，可以让这个子进程就执行这里的代码
  * args：表示传递给 target 函数的参数元组
  * kwargs：表示传递给 target 函数的参数字典
  * name：给进程设定一个名字，可以不设定
  * group：指定进程组，大多数情况下用不到

* Process创建的实例对象的常用方法：
  * start（）：启动子进程实例（创建子进程)
  * is_alive（）：判断进程子进程是否还在活看
  * join（[timeout]）：是否等待进程实例执行结束，或等待多少秒
  * terminate：不管任务是否完成，立即终止子进程

* Process创建的实例对象的常用属性：
  * name：当前进程的別名，默认为 Process-N,N为从1开始递增的整数
  * pid：当前进程的pid（进程号）

* multiprocessing模块就是跨平台版本的多进程模块，提供了一个 Process类来代表一个进程对象，这个对象可以理解为是一个独立的进程，可以执行另外的事情

#### 4、多进程中，子进程的运行机制

* python多进程中，对于子进程的运行机制是：每个子进程中，由于不同的进程之间有独立内存，不会共享，所以每个子进程是通过分别导入所在的脚本模块来实现目标函数的运行的。对于这个机制，有以下两点需要特别注意。
  * 由于每个子进程是通过导入所在脚本的模块实现模块中函数的调用的，所以，为了避免将创建子进程的语句也被导入（因为这样就会造成无限循环创建子进程，这显然是不允许的，因此python禁止了在子进程中再创建子进程，否则会报错），创建子进程的语句必须在if __name__=='__main__'语句之后定义，或者如果创建子进程的语句是定义在一个函数中的，那么这个函数调用必须在if __name__=='__main__'语句之后，这是python多进程中的强制性语法规则。
  * 子进程中的目标函数是被导入的，这样子进程才可以调用到进程需要的目标函数，因此，目标函数必须在if __name__=='__main__'语句之前定义，如果是在该语句之后定义，那么由于被导入时这部分是不会被导入的，所以运行时就会报"被导入的主模块没有目标函数属性"这样的错误。

#### 5、进程间通信-Queue

* 每个进程都有自己的地址空间、内存、数据栈以及其他记录其运行状态的辅助数据，进程之间没有共享空间
* Python中 multiprocessing.Queue()和 queue.Queue()区别

  * queue.Queue是进程内非阻塞队列，进程内的通信
  * multiprocess.Queue是跨进程通信队列，进程间的通信
  * 多进程前者是各自私有，后者是各子进程共有。
  * Process进程之间有时需要通信，操作系统提供了很多机制multiprocessing.Queue()来实现进程间的通信。
* 多进程使用队列进行通信时，一定要将队列当作参数传入进程的目标函数中。如果将队列设置在外部，进程之间是不共享队列的，每个队列都拥有自己的队列。



#### 6、进程池Pool

* 当需要创建的子进程数量不多时，可以直接利用 multiprocessing中的 Process动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到 multiprocessing模块提供的Pool方法
* 进程池多用于多个进程执行同一个任务
* 初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程来执行新的任务
* Pool常用方法：
  * apply_async（func[, args[,kwds]])：使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表 
  * close()：关闭Pool，使其不再接受新的任务
  * terminate()：不管任务是否完成，立即终止
  * join()：主进程阻塞，等待子进程的退出，必须在close或 terminate之后使用
* 获取进程池中进程的id，os.getpid()



#### 7、进程池中多进程通信-Manager.Queue

* 如果要使用Pool创建进程，就需要使用 multiprocessing.Manager（中的 Queue0，而不是multiprocessing Queue）。
* q = Manager().Queue()，创建进程池内的队列







### 5、协程

* 协程：微线程

* 协程的本质是单任务，依赖于线程，协程相当于线程占用的资源更小。

#### 1. 什么是协程？

协程是 python个中另外一种实现多任务的方式，只不过比线程更小占用更小执行单元（需要的资源更少）。为啥说它是一个执行单元，因为它自带cPU上下文。这样只要在合适g的时机，我们可以把一个协程切换到另一个协程。只要这个过程中保存或恢复cPU上下文那么程序还是可以运行的。

通俗的理解：在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都由开发者自己确定

#### 2. 协程和线程差异

在实现多任务时，线程切换从系统层面远不止保存和恢复cPU上下文这么简单。操作系统为了程序运行的高效性每个线程都有自己缓存 Cache等等数据，操作系统还会帮你做这些数据的恢复操作。所以线程的切换比较耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。

* 为什么协程效率这么高呢？
  * 主要是因为协程的切换是程序之间进行决定的，切换过程只有自己的程序中，这也是跟线程区别的地方，线程切换需要依赖操作系统进行。

#### 3.创建协程

1. greenlet模块。

   由开发者自己决定何时切换协程

```python
from greenlet import greenlet
# 创建两个协程
g1 = greenlet(work1)
g2 = greenlet(work2)

# 执行协程
g1.switch()
```

2. gevent模块

   gevent.monkey.patch_all()  # 当协程有耗时操作时主动切换协程，不局限于gevent.sleep()

```python
from gevent import monkey
import gevent
# 创建两个协程
# spawn：开启协程（第一个参数为协程要执行的任务，可以传入目标函数所需的参数）
g1 = gevent.spawn(work)  # 用gevent创建的协程，创建完成就会立即执行任务
g2 = gevent.spawn(work)  # 不像线程、进程需要start方法才开始执行任务
"""协程几乎不耗费资源可以开启大量协程，做并发非常合适"""

# 迫使线程等待两个协程执行完成后再往下进行
# 线程默认是不等待协程执行完成的
g1.join()
g2.join()
```





### 6、进程、线程、协程

#### 1、概念

1. 进程

   进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。

   进程是应用程序的启动实例，进程拥有代码和打开的文件资源、数据资源、独立的内存空间。

2. 线程

   线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。

   线程从属于进程，是程序的实际执行者，一个进程至少包含一个主线程，也可以有更多的子线程，线程拥有自己的栈空间。

3. 协程

   协程又称微线程,是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

   协程（Coroutines）是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。

4. 简单来说，一个进程内可以包含多个线程运行，如果是多核CPU的就支持多个线程（Python例外）并行，一个线程之内可以开多个协程，但是不管怎么样，多个协程之间是串行的，也就是不管什么时候，线程内中只有一个协程函数在运行，其他函数则被挂起。

#### 2、联系与区别：

1. 线程与进程的比较

   线程是指进程内的一个执行单元,也是进程内的可调度实体。

   一个进程默认有一个线程

   线程与进程的区别:

   1)同一个进程中的线程共享同一内存空间，但是进程之间是独立的。

   2)同一个进程中的所有线程的数据是共享的（进程通讯），进程之间的数据是独立的。

   3)对主线程的修改可能会影响其他线程的行为，但是父进程的修改（除了删除以外）不会影响其他子进程。

   4)一个进程至少有一个线程

   5)同一个进程的线程之间可以直接通信，但是进程之间的交流需要借助中间代理来实现。

   6)创建新的线程很容易，但是创建新的进程需要对父进程做一次复制。

   7)一个线程可以操作同一进程的其他线程，但是进程只能操作其子进程。

   8)线程启动速度快，进程启动速度慢（但是两者运行速度没有可比性）。

2. 协程与线程的比较

   1) 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。

   2) 线程进程都是同步机制，而协程则是异步

   3) 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态（生成器原理）



#### 3、通俗描述

* 有一个老板想要开个工厂进行生产某件商品（例如剪子）
* 他需要花一些财力物力制作一条生产线，这个生产线上有很多的器件以及材料这些所有的为了能够生产剪子而准备的资源称之为：进程
* 只有生产线是不能够进行生产的，所以老板的找个工人来进行生产，这个工人能够利用这些材料最终一步步的将剪子做出来，这个来做事情的工人称之为：线程
* 这个老板为了提高生产率，想到3种办法：
  * 在这条生产线上多招些工人，一起来做剪子，这样效率是成倍增长，即**单进程多线程方式**
  * 老板发现这条生产线上的工人不是越多越好，因为一条生产线的资源以及材料毕竟有限，所以老板又花了些财力物力购置了另外一条生产线，然后再招些工人这样效率又再一步提高了，即**多进程多线程方式**
  * 老板发现，现在已经有了很多条生产线，并且每条生产线上已经有很多工人了（即程序是多进程的，每个进程中又有多个线程），为了再次提高效率，老板想了个损招，规定：如果某个员工在上班时临时没事或者再等待某些条件（比如等待另一个工人生产完谋道工序之后他才能再次工作），那么这个员工就利用这个时间去做其它的事情，那么也就是说：如果一个线程等待某些条件，可以充分利用这个时间去做其它事情，其实这就是：协程方式

#### 4、简单总结

1. 进程是资源分配的单位
2. 线程是操作系统调度的单位
3. 进程切换需要的资源很最大，效率很低
4. 线程切换需要的资源一般，效率一般（当然了在不考虑GIL锁的情况下）
5. 协程切换任务资源很小，效率高
6. 多进程、多线程根据cpu核数不一样可能是并行的，但是协程是在一个线程中所以只能是并发。（python中的线程少数情况下能做并行，当一个线程有IO写文件长时间操作时，切换到其他线程任务中执行，这样一个线程在IO写文件，另一个线程在执行其他任务，就产生了并行）
7. python中的线程由于GL锁的的存在，并不能够实现并行





# 前端

## 一、html

* HTML：超文本标记语言，是网页制作必备的编程语言“超文本"就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素

* 前端开发中最基本也是最必须的三个技能。前端的开发中，在页面的布局时，
  * HTML：页面结构：可以把他看成一个文档，定义展示页面的内容结构。
  * CS5：页面表现：元素大小、颜色、位置隐原或导示、部分动画效果。
  * Javascript：页面行为：部分动画效果、页面与用户的交互、页面功能
  
* [页面标签笔记]: ./Web测试3张小姐.ppt

  



### 1、HTML页面结构

超文本标记语言的结构包括"头"部分（Head）、和"主体"部分（Body），其中"头"部提供关于网页的信息，"头"部分提供网页的目体内容

![image-20210821083957394](Python测试开发.assets/image-20210821083957394.png)



### 2、常见的html标签

* 学习网址

  https://www.runoob.com/tags/ref-byfunc.html

1. 注释标签<!--这是一段注释，不会在浏览器中显示-->

2. 标题标签

​	\<h1>这是标题H1</h1\>

​	\<h2>这是标题H2</h2\>

​	\<h3>这是标题H3</h3\>

​	\<h4>这是标题H4</h4\>

​	\<h5>这是标题H5</h5\>

​	\<h6>这是标题H6</h6\>

3. 段落和换行标签

   \<p></p\>：标签定义段落。元素会自动在其前后创建一些空白。浏览器会自动添加这些空间，也可以在样式表中规定。
   \<br>：插入一个简单的换行符。标签是空标签，意味着它没有结束标签 
   \<hr>：标签在HTML页面中创建一条水平线。水平分隔线（ horizontal rule）可以在视觉上将文档分隔成各个部分，在HTML中，\<hr>标签没有结束标签。

4. 块标签

   \<div></div\>标签：标签块元素，表示一块内容，没有具体的语义。div标签可以把文档分割为独立的、不同的部分。

   \<span></span\>标签：行内元素，表示一行中的一小段内容，没有具体的语义\<span>没有固定的格式表现。当对它应用样式时，它才会产生视觉上的变化

5. 含样式和语义的行内标签

   | 标签                | 含义                                             |
   | ------------------- | ------------------------------------------------ |
   | \<i></i\>           | 行内元素，字体斜体                               |
   | \<em></em\>         | 行内元素，语义为强调内容，表示重要（倾斜效果）   |
   | \<b></b\>           | 行内元素，字体加粗                               |
   | \<strong></strong\> | 行内元素，语义为强调内容，表示非常要（效果加粗） |

6. 图像标签和链接标签

   1. \<img>标签：向网页中嵌入一幅图像。请注意，从技术上讲，\<img>标签并不会在网页中插入图像，而是从网页上链接图像。\<img>标签创建的是被引用图像的占位空间

      \<img>标签有两个必需的属性：src属性和alt属性。src-图像链接位置，alt-当图片显示失败时显示alt提示内容。
      <img src="http://www.lemonban.com/images/upload/image/20190219/1550546293631.3pg alt=”柠檬班“>

   | 属性   | 描述               |
   | ------ | ------------------ |
   | alt    | 规定图像的替代文本 |
   | src    | 规定显示图像的URL  |
   | height | 定义图像的高度     |
   | width  | 设置图像的宽度     |

   

   2. \<a></a\>标签：定义超链接，用于从一个网页跳转到另一个网页。

      \<a></a\>标签有一个必须属性：href属性-链接网址

   3. link标签（放在头部）

      链接到一个外部样式，即链接到外部的css文件

7. 列表

   1. 有序列表\<ol></ol\>

      在网页上定义一个有编号的内容列表可以用\<ol></ol\>、<1i></li\>（每一行li代表一行内容）配合使用来实现，代码如下：

      \<ol>
      \<1i>列表文字一</1i\>
      \<1i>列表文字二</1i>
      <1i>列表文字三</1i\>
      </ol\>

      在网页上生成的列表，每条项目上会按1、2、3编号，有序列表在实际开发中较少使用。

   2. 无序列表\<u1></ul\>

      在网页上定义一个无编号的内容列表可以用\<u1></ul\>、<1i></li\>配合使用来实现，代码如下：
      <u1>
      <1i>< a href="#">标题一</a></1i>
      <1i>< a href="#">标题二</a></1i>
      <1i>< a href="#">标题三</a></1i>
      </u1>
      在网页上生成的列表，每条项目上会有一个小图标

   3. 定义列表

      d1：标签定义了定义列表（ definition list）。标签用于结合dt定义列表中的项目和dd描述列表中的项目
      <d1>
      <dt>python</dt>
      <dd>解程性语言</dd>
      <dt>java</dt>
      <dd译型语言</dd
      </d1>

8. 表格

   \<table></table\>:标签定义HTML表格。
   
   简单的HTML表格由tabe元素以及一个或多个tr、th或td元素组成。tr元素定义表格行，th元素定义表头，td元素定义表格单元
   
   \<table border="1”>
   	<tr>
   		<th>name</th>
   		<th>java</th>
   		<th>python</th>
   	</tr>
   	<tr>
   		<td>小明</td>
   
   ​		<td>精通</td>
   
   ​		<td>熟悉</td>
   ​	</tr>
   ​	<tr>
   ​		<td>小张</td>
   ​		<td>不会</td>
   ​		<td>不会</td>
   ​	</tr>
   </table\>

### 3、HTML表单

1. form标签

   * \<form></form\>：标签用于为用户输入创建HTML表单，表单能够包含input元素，比如文本字段、复选框、单选框提交按钮等等。

   * form标签的属性：

     | 属性   | 描述                                    |
     | ------ | --------------------------------------- |
     | action | 定义表单数据提交地址                    |
     | method | 定义表单提交的方式（常见的有get和post） |

   * form表单中包含的元素

     | 元素标签              | 作用                                         |
     | --------------------- | -------------------------------------------- |
     | <label></label>       | 定义文字标注                                 |
     | <input>               | 定义通用的表单元素                           |
     | <textarea><textarea/> | 定义多行文本输入框                           |
     | <select><select/>     | 定义下拉表单元素                             |
     | <option><option/>     | 与<select>标签配合，定义下拉表单元素中的选项 |

2. input标签

   value属性：定义表单元素的值，默认值

   name属性：定义表单元素的名称，此名称是提交数据时的键名 

   type属性：

   | 值       | 作用                                        |
   | -------- | ------------------------------------------- |
   | text     | 定义单行文本输入框                          |
   | password | 定义密码输入框                              |
   | radimit  | 定义单选框                                  |
   | checkbox | 定义复选框                                  |
   | file     | 定义上传文件                                |
   | submit   | 定义提交按钮                                |
   | button   | 定义一个普通按钮                            |
   | reset    | 定义重置按钮                                |
   | image    | 定义图片作为提交按钮，用src属性定义图片地址 |
   
3. label标签

   <label>标签为 input元素定义标注（标记）

   <label>元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。

   <label>标签的for属性应当与相关元素的id属性相同

4. textarea标签

   textarea标签定义多行的文本输入控件。

   文本区中可容纳无限数量的文本，其中的文本的默认字体是等宽字体（通常是 Courier）。

   可以通过cols和rows属性来规定 textarea的尺寸，更好的办法是使用css的 height和width属性

   | 属性        | 值               | 描述                                 |
   | ----------- | ---------------- | ------------------------------------ |
   | autofocus   | autofocus        | 规定在页面加载后文本区域自动获得焦点 |
   | cols        | number           | 规定文本区内的可见宽度               |
   | disabled    | disabled         | 规定禁用文本区                       |
   | form        | form_id          | 规定文本区域所属的一个或多个表单     |
   | maxlength   | number           | 规定文本区域的最大字符数             |
   | name        | name_of_textarea | 规定文本区的名称                     |
   | placeholder | text             | 规定描述文本区域预期值的简短提示     |
   | readonly    | readonly         | 规定文本区为只读                     |
   | required    | required         | 规定文本区域是必填的                 |
   | rows        | number           | 规定文本区内的可见行数               |

5. select标签

   select元素可创建单选或多选菜单，也可以用于选择数据提交表单

6. option标签

   option元素定义下拉列表中的一个选项。

   浏览器将< option>标签中的内容作为< select>标签的菜单或是滚动列表中的一个元素显示。

   option元素位于 select元素内部



### 4、内联框架

​		iframe元素会创建包含另外一个档的内联框架（即行内框架）



### 5、HTML元素分类

* 元素就是标签，布局中常用的有三种标签，块元素、内联元素、内联块元素，了解这三种元素的特性，才能熟练的进行页面布局。

1. 块元素

   块元素，也可以称为行元素（会自动换行），布局中常用的标签如：div、p、ul、li、h1-h6、dl、dd等等都是块元素，它在布局中的行为：

   * 支持全部的样式
   * 如果没有设置宽度，默认的宽度为父级宽度100%
   * 盒子占据一行，即使设置了宽度

2. 内联元素

   内联元素，也可以称为行内元素（不会自动换行），布局中常用的标签如：a、span、em、b、 strong等都是内联元素，它们在布局中的行为：

   * 支持部分样式（不支持宽、高、 margin上下、 padding上下）
   * 宽高由内容决定
   * 盒子并在一行
   * 代码换行，盒子之间会产生间距
   * 子元素是内联元素，父元素可以用 ext-align属性设置子元素水平对齐方式

3. 内联块元素

   内联块元素，也叫行内块元素，是新增的元素类型，现有元素没有归于此类别的，img和input元素的行为类似这种元素，但是也归类于内联元素，我们可以用 display属性将块元素或者内联元素转化成这种元素。它们在布局中表现的行为：

   * 支持全部样式
   * 如果没有设置宽高，宽高由内容决定
   * 盒子并在一行
   * 代码换行，盒子会产生间距
   * 子元素是内联块元素，父元素可以用 text-align属性设置子元素水平对齐方式

4. 三种元素相互转化

   可以通过 display属性来相互转化，不过实际开发中，块元素用得比较多，所以我们经常把内联元素转化为块元素，少量转化为内联块，而要使用内联元素时，直接使用内联元素，而不用块元素转化了。

   **display属性**

   display属性是用来设置元素的类型及隐藏的，常用的属性有：

   * none 元素隐藏目不占位置
   * block 元素以块元素显示
   * inline 元素以内联元素显示
   * inline-block元素以内联块元素显示

## 二、css

学习网站：https://www.w3school.com.cn/css/index.asp

### 1、css介绍和引用

​	CSS概述：层量样式表，是一种用来表现HTML或XML等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化，CSS能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力

#### css的基本语法

css规则由两个主要的部分构成：选择器，以及一条或多条声明。

选择器通常是您需要改变样式的HTML元素，每条声明由一个属性和一个值组成。

![image-20210822145744442](Python测试开发.assets/image-20210822145744442.png)

#### css引入方法：

1. 外联式：通过link标签，链接到外部样式表到页面中（在head写）

   ~~~html
   <link rel="stylesheet" type="text/css" href="css/main.css">
   ~~~

2. 嵌入式：通过style标签，在网页上创建嵌入的样式表（在head写）

   ~~~html
   <style type="text/css">
       <div> {width:100px; height:100px; color:red;}
   </style>
   ~~~

3. 内联式：通过标签的style属性，在标签上直接写样式（在body写）

   ~~~html
   <div style="width:100px; height:100px; color:red">****</div>
   ~~~


### 2、css背景

#### 设置背景色

* p {background-color: red;}

#### 设置背景图像

* background-image：要把图像放入背景，属性的默认值是none，表示背景上没有放置任何图像。如果需要设置一个背景图像，必须为这个属性设置一个URL值

  body {background-image:url("/i/paper.jpg")}  (大多数背景图像都是应用的整个body元素)

* 如果需要在页面上对背景图像进行平铺（当图像大小不够页面时，会重复粘贴图像），可以使用background-repeat属性

  默认背景图像将从一个元素的左上角开始

  属性值：

  repeat：导致图像在水平垂直方向上都平铺，就像以往背景图像的通常做法一样

  repeat-x：图像只在水平上重复，

  repeat-y：图像在垂直方向上重复

  no-repeat：不允许图像在任何方向重复

#### 背景定位

* 可以利用background-position属性改变图像在背景中的位置
* 定位方式：位置关键字、百分比

#### 背景关联

如果文档比较长，那么当文档向下滚动时，背景图像也会随之滚动。当文档滚动到超过图像的位置时，图像就会消失。可以通过 [background-attachment 属性](http://www.sz-seo.org/w3cschool/cssref/pr_background-attachment.html)防止这种滚动。通过这个属性，可以声明图像相对于可视区是固定的（fixed）

### 3、颜色表示法

[w3school]: https://www.w3school.com.cn/css/css_colors.asp

* 有三种颜色表示方法：

  颜色名表示，比如：red, green等

  rgb表示，比如：rgb(255,0,0)表示红色。rgba(255,0,0,0.5)，第四位表示透明度，取值0-1之间。

  16进制数值表示，比如：#FFFFF00表示黄色

### 4、css文本样式

* 常用的应用文本css样式：

  | 属性        | 描述                                                   | 实例                                                         |
  | ----------- | ------------------------------------------------------ | ------------------------------------------------------------ |
  | color       | 设置文字的颜色                                         | color:red；                                                  |
  | font-size   | 设置文字的大小                                         | font-size：12px                                              |
  | font-family | 设置文字的字体                                         | font-family：“微软雅黑”                                      |
  | font-style  | 设置字体是否倾斜                                       | 不倾斜：font-style:normal；倾斜：font-style:italic；         |
  | font-weight | 设置文字是否加粗                                       | 设置加粗：font-weight:bold；设置不加粗：font-weight:normal； |
  | line-height | 设置文字的行高（行高相当于在每行文字的上下同时加间距） | line-height：3px                                             |
  | text-indent | 设置文字首行缩进                                       | 设置文字首行缩进24px：text-indent:24px；                     |
  | text-align  | 设置文字水平对齐方式                                   | 设置文字水平居中：text-align:center;                         |

* 设置文字的几个属性的简写代码：

  * 顺序如下：font：是否加粗  字号/行高  字体；例如font:normal 12px/36px '微软雅黑'；



### 5、css选择器

[w3school]: https://www.w3school.com.cn/css/css_selectors.asp

- 简单选择器（根据名称、id、类来选取元素）
- 组选择器，多个元素共用一个样式style。p,h1,div {background:red;}
- [组合器选择器](https://www.w3school.com.cn/css/css_combinators.asp)（根据它们之间的特定关系来选取元素）
- [伪类选择器](https://www.w3school.com.cn/css/css_pseudo_classes.asp)（根据特定状态选取元素）
- [伪元素选择器](https://www.w3school.com.cn/css/css_pseudo_elements.asp)（选取元素的一部分并设置其样式）
- [属性选择器](https://www.w3school.com.cn/css/css_attribute_selectors.asp)（根据属性或属性值来选取元素）

### 6、css模型框

[w3school]: https://www.w3school.com.cn/css/css_boxmodel.asp





## 三、JavaScript

* JavaScript的每行代码结束都必须以“；”结尾

* 学习网址，

  [菜鸟教程]: https://www.runoob.com/js/js-tutorial.html

  

### 1、js嵌入方式

#### 1、行间事件

​	<input type='button' name='**' onclick="alert('ok!');">

* 在body嵌入

#### 2、页面script标签嵌入

<script type="text/javascript">
alert('ok!')
</script>

* 在body嵌入，也可以在head中。script标签放在head中先执行，放在body后执行。
* 尽可能不在head中嵌入，浏览器加载html页面是从上往下加载，加入js中涉及一些页面元素属性时，在head部分时直接会报错没有找到元素属性，因为还没有加载到。

#### 3、外部引入

<script type="text/javascript" src="js/index.js"></script>

* 单独写一份js文件，引入进来

### 2、基础语法

#### 1、注释

* 单行注释：以//开头
* 多行注释：以/*开头，以\*/结尾
* 快捷键Ctrl+/

#### 2、变量

* 变量命名
  * 变量可以使用短名称（比如x和y），也可以使用描述性更好的名称（比如age,sum）
  * 变量必须以字母开头
  * 变量也能以$和_符号开头（不推荐）
  * 变量名称对大小写敏感（y和Y是不同的变量）
  * 驼峰命名

* 变量声明（js中的变量必须要声明）

  * javascript中变量可以先声明后赋值

    ​	var x;

    ​	x=20;

  * 也可以在声明时候直接赋值

    ​	var x=20;



#### 3、数据类型

字符串	数字	布尔	Null	数组	Undefined

* number	数字类型

  var y=3;

* string   字符串类型

  var str='python'

* boolean    布尔类型

  只有true或false两个值

* undefined   类型

  变量声明没有初始化（没有赋值），这个变量的值就是undefined

#### 4、运算符

* 算术运算符：+（加）、-（减）、*（乘）、/（除）、%（求余）

* 赋值算符：=、+=、-=、*=、/=、%=、++(自增)

* 条件运算符：==、===、>、>=、<、<=、!=、

* 逻辑运算符：&&（而且）、||（或者）、!（否）

#### 5、条件语句

* if语句

  ~~~javascript
  var a = 100;
  if(a>200){
  	alert('大于200')	
  }
  ~~~

  

  

* else语句

  ~~~javascript
  var a = 100;
  if(a>200){
  	alert('大于200')	
  }else{
  	alert(a)
  }
  ~~~

* else if 语句

  ~~~javascript
  var a = 100;
  if(a>200){
  	alert('大于200')	
  }else if (a === 100){
  	alert('等于100')
  }else{
  	alert(a)
  }
  ~~~



* switch语句

  ~~~javascript
  switch(表达式){
  	case n1:
  		代码块；
  		break;
  	case n2:
  		代码块；
  		break;
  	default:
  		默认代码块
  }
  ~~~

  * 计算一次 switch表达式
  * 把表达式的值与每个case的值进行对比
  * 如果存在匹配，则执行关联代码
  * 遇到 break关键词，它会跳出 switch代码块
  * case匹配不存在时，运行 default的代码



#### 6、函数

* 函数定义

  定义函数的关键字function，函数内的代码块，包裹在花括号中：

  ~~~javascript
  //使用关键字function，定义函数
  function func(){
  	alter('999')
  }
  //调用函数
  func()
  ~~~

  

* 函数参数 

  ~~~javascript
  //使用关键字function，定义函数
  function addNumber(var1, var2){
  	alert(var1+var2)
  }
  //调用函数
  addNumber(11,22)
  ~~~

  

* 函数返回值

  使用return来返回值。在使用return语句时，函数会停止运行，并返回指定的值

  ~~~javascript
  //使用关键字function，定义函数
  function addNumber(var1, var2){
  	return (var1+var2)
  }
  //调用函数
  var res = addNumber(11,22)
  alert(res)
  ~~~


#### 7、对象

* 创建对象

  对象由花括号分隔，在括号内部

  **方式一**

  objA = new boject();

  **方式二**

  var objA = {};

* 对象属性

  * 对象的属性以名称和值对的形式（name:vaue）来定义。属性由逗号分隔：

    ~~~javascript
    var objA={name:"python"， age:18， id:123}；
    ~~~

    

  * 创建对象属性声明可横跨多行：

    ~~~javascript
    var objA={
    name:python，
    age:18，
    id:123
    };
    ~~~

    

* 对象方法

  对象方法是作为属性来存储的函数

  ~~~javascript
  var objC = {
  	name:'abc',
  	age:19,
  	fun:function (var1,var2) {  //对象内部设置方法的时候不需要设置函数名
  	alert(var1);
  	alert(var2);
  	alert(this.age*2);
  	};
  };
  ~~~

#### 8、循环

* while循环

  ~~~
  while (条件语句){
  	循环体；
  }
  ~~~

  案例：循环弹出0-5

  ~~~javascript
  var i = 0;
  while (i<=5){
  	alert(i);
  	i++
  }
  ~~~

  

* for循环

  ~~~
  for (语句1， 语句2，语句3){
  	循环体；
  }
  语句1：在循环开始之前执行
  语句2：循环条件（成立则执行循环体）
  语句3：每一轮循环之后执行的语句
  ~~~

  案例：遍历数组

  ~~~javascript
  var aList = Array(11,22,33);
  for (var a=0;a<aList.length;a++){
  	alert(aList[a]);
  }
  ~~~

  

* for in遍历循环

  遍历数组遍历出来的是元素的下标

  ~~~javascript
  var aList = Array(1,3,5,22);
  for (i in aList){ 
      console.log(i);  // 0 1 2 3
      console.log(aList[i]);
  }
  ~~~

  

  

  遍历对象遍历出来的是对象的属性

  ~~~javascript
  var objA ={
      name : 'liufei',
      age : 27,
      gender : 'man'
  }
  for (i in objA){
      console.log(i);  //name age gender
      objA[i]  //获取对象中的属性
  }
  ~~~

  

### 3、JS操作页面

学习网址：https://www.w3school.com.cn/js/js_htmldom.asp

* DOM简介

  通过HTML DOM，可访问JavaScript HTML文档的所有元素。

  当网页被加载时，浏览器会创建页面的文档对象模型-DOM。

#### 1、获取页面标签

1、获取标签的方式

* 通常，通过 JavaScript操作HTML元素可以使用内置对象 document的方法来找到该标签。

* 通过id找到HTML元素（常用）

  document. getElementByld（）

* 通过标签名找到HTML元素——获取出来的是列表

  document.getElementsByTagName（）

* 通过类名找到HTML元素——取出来的是列表（通过类名查找HTML元素在IE567,8中无效。）

  document.getElementsByClassName（）

2、JS脚本放置HTML页面位置

1. JavaScript放到页面最下边（body内）
2. 放的window.onload触发的函数里面



#### 2、操作标签内容

* innerHTML属性

  获取元素内容的最简单方式是使用innerHTML属性。innerHTML属性对于获取或替换HTML元素的内容非常有用

* 读取节点文本

  ~~~javascript
  var odv1=document.getElementById('box');
  var content1=odv1.innertHTML;
  alert(content1)
  ~~~

* 写入节点文本

  ~~~javascript
  var odv1=document.getElementById('box')
  odv1.innerHTML='HHHHH'
  ~~~

* innerText属性同理

#### 3、修改标签属性

* 操作属性的方法

  * “.”操作
  * “[]”操作

* 读取属性

  ~~~javascript
  <input type="text">
      
  var input=document.getElementsByTagName('input')[0];
  console.log(input.type);  //获取元素属性
  ~~~

  

* 修改属性

  ~~~javascript
  input.type='password';  //修改元素属性
  ~~~

  

* 注意，操作class属性时，不是class而是className

  ~~~javascript
  a1.className='hied';
  ~~~



4、onclick事件

* onclick：点击了该元素

* 事件属性添加JavaScript代码

  ~~~javascript
  <div class="dv1" id="dv01" onclick="tank()">这是个弹框</div>
  
  //定义一个函数，负责弹框
  function tank(){
  	alert('hello');
  };
  ~~~

  

## 四、jquery

### 1、jquery介绍和引用

* jQuery是目前使用最广泛的JavaScript函数库
* jQuery在线学习手册
  * https://www.runoob.com/manual/jquery/
  * https://www.w3school.com.cn/jquery/index.asp
* 版本下载：https://code.jquery.com/
  * jquery可以下载到本地引用
  * 也可以直接连接到在线地址引用
* 引用方式等同于引用JavaScript文件





### 2、jQuery选择器

#### 1、jQuery基本选择器

jQuery选择器可以快速的选择元素，选择规则和css样式相同，使用length属性判断是否选择成功。



| 实例                  | 描述         |
| --------------------- | ------------ |
| $('#btn1')            | //id选择器   |
| $('.box1')            | //类选择器   |
| $('li')               | //标签选择器 |
| $('#ul li span')      | //层级选择器 |
| $('input[name=user]') | //属性选择器 |

#### 2、选择同辈和父辈元素



| 实例                  | 描述                               |
| --------------------- | ---------------------------------- |
| $('div').prev();      | //选择div元素前面紧挨的同辈元素    |
| $('div').prevAll();   | //选择div元素之前所有的同辈元素    |
| $('div').next();      | //选择div元素后面紧挨的同辈元素    |
| $('div').netAll();    | //选择div元素后面所有的同辈元素    |
| $('div').parent();    | //选择div的父元素                  |
| $('div').children();; | //选择div的所有子元素              |
| $('div').siblings();  | //选择div的同级元素                |
| $('div').find('.cs')  | //选择div内的class属性等于cs的元素 |
|                       |                                    |



#### 3、选择过滤

| 实例                    | 描述                         |
| ----------------------- | ---------------------------- |
| $('div').has('p');      | //选择包含p元素的div元素     |
| $('div').not('.cs');    | //选择class不等于cs的div元素 |
| $('div').filter('.cs'); | //选择class等于cs的div元素   |
| $('div').eq(5);         | //选择第6个div元素           |



#### 4、获取元素的索引值

* 有时候需要获得匹配元素相对于其同胞元素的索引位置，此时可以用index()方法获取。

  ~~~javascript
  console.log($('#li3').index())  //元素索引从0开始
  ~~~



### 3、jQuery样式操作

#### 1、获取元素样式

~~~javascript
$('div').css('width');
$('div').css('color');
~~~





#### 2、修改元素样式

~~~javascript
$('div').css('width','30px');
$('div').css('height','30px');
$('div').css({background:'red'l,color:'black',fontsize:'30px'})
~~~





#### 3、添加或者移除class属性

~~~javascript
$('#div1').addClass('cs2'); //添加class属性
$('#div1').removeClass('cs2');  //移除class属性

$('#div1').toggleClass('cs2');  //重复切换样式
~~~

#### 4、绑定click事件

给元素绑定click事件，如下

~~~javascript
$('#btn1').click(function(){
	****
})
~~~

* jquery链式调用

  jQuery对象的方法会在执行后返回这个jQuery对象，所有jQuery对象的方法可以连起来写

  ~~~javascript
  $(this).next().toggleClass('show').parent().siblings().children('ul').removeClass('show')
  ~~~



#### 5、jQuery操作属性

| 方法         | 描述                             |
| ------------ | -------------------------------- |
| attr()       | 设置或返回匹配元素的属性和值     |
| removeAttr() | 从所有匹配的元素中移除指定的属性 |



#### 6、jQuery操作元素

* 获取文本内容
  * text()：设置或返回所选元素的文本内容
  * html()：设置或返回所选元素的内容（包括HTML标记）
  * val()：设置或返回表单字段的值
* 添加新的HTML内容
  * append()：在被选元素的结尾插入内容。（插在被选元素内部）
  * prepend()：在被选元素的开头插入内容（插在被选元素内部）
  * after()：在被选元素之后插入内容（插在被选元素外部）
  * before()：在被选元素之前插入内容（插在被选元素外部）
* 删除元素/内容
  * remove()：删除被选元素及其子元素
  * empty()：从被选元素中删除子元素（只删除子元素，被选中的元素不会被删除）

#### 7、jQuery效果函数

| 方法          | 描述                                           |
| ------------- | ---------------------------------------------- |
| animate()     | 对被选元素应用“自定义的动画                    |
| fadIn()       | 逐渐改变被选元素的不透明度，从隐藏到可见       |
| fadeOut()     | 逐渐改变被选元素的不透明度，从可见到隐藏       |
| hide()        | 隐藏被选的元素                                 |
| show()        | 显示被选的元素                                 |
| slideDown()   | 通过调整高度来滑动显示被选元素                 |
| slideToggle() | 对被选元素进行滑动隐藏和滑动显示的切换         |
| slideUp()     | 通过调整高度来滑动隐藏被选元素                 |
| stop()        | 停止在被选元素上运行动画                       |
| toogle()      | 对被选元素进行隐藏和显示的切换（通过点击实现） |



#### 8、jQuery事件

| 事件         | 描述                                         |
| ------------ | -------------------------------------------- |
| click()      | 鼠标单击                                     |
| change()     | 元素改变                                     |
| mouseover()  | 鼠标进入（进入子元素也触发）                 |
| mouseout()   | 鼠标离开（离开子元素也触发）                 |
| mouseenter() | 鼠标进入（进入子元素不触发）                 |
| mouseleave() | 鼠标离开（离开子元素不触发）                 |
| hover        | 同时为mouseenter和mouseleave事件指定处理函数 |
| ready()      | DOM加载完成                                  |
| resize()     | 浏览器窗口的大小发生改变                     |
| scroll()     | 滚动条的位置发生变化                         |
| submit()     | 用户提交表单                                 |
|              |                                              |
|              |                                              |
|              |                                              |

#### 9、Ajax













# Flask

## 一、课前铺垫

### 1、selenium原理

实际上webdriver.exe是一个服务，代码驱动服务启动，然后调用服务中的某个接口去执行相关操作。

~~~python
driver = webdriver.Chrome(port=4567)  # 启动webdriver.exe服务。并且指定端口号运行这个服务。
driver.get('http://www.baidu.com')

# 通过启动webdriver服务，然后通过request接口发起请求webdriver中接口，操作浏览器访问百度
data = {'url':'http://www.baidu.com'}
api_address = 'http://localhost:4567/session/{}/url'.format(driver.session_id)
res = requests.post(api_address, json=data)
print(res.status_code)
print(res)
~~~

### 2、静态服务器和动态服务器

静态服务器

![技术分享图片](Python测试开发.assets/20200509185957282135.png)



动态服务器

![img](Python测试开发.assets/1234412-20200509181838333-1561983917.png)





![image-20211010185031284](Python测试开发.assets/image-20211010185031284.png)

### 3、最简单的web服务器simple

~~~python
from wsgiref.simple_server import make_server

def listen(env, make_reponse):
    # env，前端url的路径、参数等信息全部存储在此环境变量中
    # make_reponse，返回响应头reponse状态码，header
    make_reponse('200 ok', [('content-type', 'text/plain')])

    return [b'hello']  # 页面的返回内容必须bytes格式返回

server = make_server("", 6001, app)  # 创建一个web服务器
server.serve_forever()  # 启动这个web服务器		
~~~

原理：

* 第一行def listen():定义了一个名为listen的回调函数(callable)，接受两个参数，env 和 make_response，env 是一个字典包含了 CGI 中的环境变量。
* 第二行调用了make_response，状态指定为“200 OK”，消息头指定为内容类型是“text/plain”。make_response 也是一个 callable，接受两个必须的参数，status（HTTP 状态）和 response_headers（响应消息的头）。
* 第三行将响应消息的消息体返回。

注意：

* status必须是字符串，不能是200数字，且必须又4个字符以上
* header是一个元组构成的列表，不能是字典
* 返回值是列表且要是byte类型。可以利用encode()方法进行编码。

### 4、web服务器处理不同的url接口

~~~python
from wsgiref.simple_server import make_server

def home():
    return 'hello'
def login():
    return 'login'
def projects():
    return 'projects'
patterns = {  # 路由集中管理
    '/':home,
    '/login':login,
    '/projects':projects
}
def app(env, start_reponse):
    url = env.get('PATH_INFO')
    if (url is None) or (url not in patterns.keys()):
        start_reponse('404 not found', [('content-type', 'text/plain')])
        return [b'page not found']

    resp = patterns.get(url)
    if resp is None:
        start_reponse('404 not found', [('content-type', 'text/plain')])
        return [b'page not found']
    start_reponse('200 ok', [('content-type', 'text/plain')])
    return [resp().encode()]


server = make_server("", 6001, app)  # 创建一个web服务器
server.serve_forever()  # 启动这个web服务器
~~~



### 5、web服务器处理url中的参数

~~~python
from wsgiref.simple_server import make_server

def home(request):
    return 'hello'

def login(request):
    return 'login'

def projects(request):
    return 'projects'

patterns = {
    '/': home,
    '/login': login,
    '/projects': projects
}

def app(env, start_reponse):
    url = env.get('PATH_INFO')
    params = env.get('QUERY_STRING')  # 获取env中的url？后面的前端传入的参数
    if (url is None) or (url not in patterns.keys()):
        start_reponse('404 not found', [('content-type', 'text/plain')])
        return [b'page not found']

    resp = patterns.get(url)
    if resp is None:
        start_reponse('404 not found', [('content-type', 'text/plain')])
        return [b'page not found']
    start_reponse('200 ok', [('content-type', 'text/plain')])
    return [resp(params).encode()]


server = make_server("", 6001, app)  # 创建一个web服务器
server.serve_forever()  # 启动这个web服务器
~~~



### 6、web服务器指定不同类型的响应报文格式

~~~python
def app(env, start_reponse):
    url = env.get('PATH_INFO')
    params = env.get('QUERY_STRING')  # 获取env中的url？后面的前端传入的参数
    if (url is None) or (url not in patterns.keys()):
        # 字符串格式
        # start_reponse('404 not found', [('content-type', 'text/plain')])
        # return [b'page not found']

        # html格式
        # start_reponse('404 not found', [('content-type', 'text/html')])
        # return [b'<p style="color:red">page not found</p>']

        # json格式
        start_reponse('404 not found', [('content-type', 'application/json')])
        msg = {"msg":"page not found"}
        return [json.dumps(msg).encode()]
~~~



路由：url和处理程序的关系

flask：路由通过装饰器进行管理，适用于轻微型项目

django：路由通过集中管理，适用于大型项目



### 7、WSGI协议

PythonWeb服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI)是Python应用程序或框架和Web服务器之间的一种接口，已经被广泛接受, 它已基本达成它的可移植性方面的目标。



WSGI区分为两个部分：一为“[服务器](https://baike.baidu.com/item/服务器)”或“网关”，另一为“应用程序”或“应用框架”。在处理一个WSGI请求时，服务器会为应用程序提供环境信息及一个回调函数（Callback Function）。当应用程序完成处理请求后，透过前述的回调函数，将结果回传给服务器。





## 二、Flask基础

一个微型web框架application

安装：pip install flask

flask 依赖两个包：werkzeug(用于处理application)、jinja2(用于渲染html)。flask主要就是对这两个库进行了组合封装。

### 1、创建应用

~~~python
from flask import Flask

app = Flask(__name__)
app.run()

# 此时还没有配置路由即可以访问的URL地址，此时在浏览器输入网址会出现错误
~~~

name 的作用

Flask类只有一个必须指定的参数，即程序主模块或者包的名字，`__name__`是系统变量，该变量指的是本py文件的文件名。主要是用来确定应用的位置，以便获得静态文件和模板文件的目录。比如图像等静态文件和html文件。



### 2、定义路由

路由定义：处理URL和函数之间的绑定关系的程序叫做路由。

~~~python
@app.route('/hello')
def index():
    return 'welcome to python world'  # 响应
~~~

注意：此时访问根目录会报错404，因为没有定义根目录的处理逻辑

### 3、请求

利用flask中的request库来获取前端浏览器的请求的相关参数

from flask import request，request存储了请求参数、地址等环境信息相当于simple_server中的env环境变量

### 4、响应

在处理的函数进行return返回相应的响应报文，支持html、text、json。

也可以返回某个HTML文件，需要利用flask中的render_template库

~~~python
from flask import Flask  # Flask是核心类
from flask import request  
from flask import render_template  # 返回某个静态文件模板时导入
# 初始化application
app = Flask(__name__, template_folder='templates')  # template_folder参数用于指定模板在哪个目录下，默认templates

# 添加路由
@app.route('/')
def index():
    args = request.args  # 获取请求参数，以字典的形式返回
    name = args.get('name')
    print(name)
    # return 'hello'  # 返回字符串格式的响应体
    # return '<p style="color:red">hello</p>'  # 返回html内容
    return render_template('index.html')  # 直接将html文件返回

#运行服务器
app.run()
~~~



### 5、整体流程

~~~python
"""第一部分，初始化：所有的Flask都必须创建程序实例，
web服务器使用wsgi协议，把客户端所有的请求都转发给这个程序实例
程序实例是Flask的对象，一般情况下用如下方法实例化
Flask类只有一个必须指定的参数，即程序主模块或者包的名字，__name__是系统变量，该变量指的是本py文件的文件名"""
 
from flask import Flask
app = Flask(__name__)
 
#  第二部分，路由和视图函数：
#  客户端发送url给web服务器，web服务器将url转发给flask程序实例，程序实例
#  需要知道对于每一个url请求启动那一部分代码，所以保存了一个url和python函数的映射关系。
#  处理url和函数之间关系的程序，称为路由
#  在flask中，定义路由最简便的方式，是使用程序实例的app.route装饰器，把装饰的函数注册为路由
 
@app.route('/')
def hello_world():
    return __name__
 
 
#  第三部分：程序实例用run方法启动flask集成的开发web服务器
#  __name__ == '__main__'是python常用的方法，表示只有直接启动本脚本时候，才用app.run方法
#  如果是其他脚本调用本脚本，程序假定父级脚本会启用不同的服务器，因此不用执行app.run()
#  服务器启动后，会启动轮询，等待并处理请求。轮询会一直请求，直到程序停止。
 
if __name__ == '__main__':
    print('dd',__name__)
    app.run()
如上述代码所示，app是flask的实例，功能就是接受来自web服务器的请求，
浏览器将请求给web服务器，web服务器将请求给app ,
app收到请求，通过路由找到对应的视图函数，然后将请求处理，得到一个响应response
然后app将响应返回给web服务器，
web服务器返回给浏览器，
浏览器展示给用户观看，流程完毕。

~~~



### 6、运行服务器的方式

* python形式：app.run()

* flask命令行形式：python -m flask：

  ~~~python
  # 进入程序所在路径的终端
  set FLASK_APP = demo.py（文件名）
  
  flask run		
  ~~~



### 7、MVC

* 分层设计理念

#### 1、组成

* model，主要用来处理数据库相关的逻辑
  * 模型（model）程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计（可以是实现具体的功能）
* view，返回的前端展示内容（狭义上就是前端展示的HTML文档）
  * 视图（View）界面设计人员进行图形设计
* control，视图函数，接收请求，响应结果
  * 控制器（controller）负责转发请求，对请求进行处理



![image-20211017172332284](Python测试开发.assets/image-20211017172332284.png)

### 8、Flask核心对象

#### static_url_path和static_folder

* static_url_path：告诉程序处理静态文件的url路径

* static_folder：告诉程序静态文件放在硬盘的哪个位置了

注意：

- 如果static_folder未被指定（也就是默认值static），那么static_url_path取为static
- 如果static_folder被指定了，那么static_url_path等于static_folder的最后一级文件夹名称。
- 手动指定static_url_path时，如果static_url_path不为空串，url的路径必须以/开头，如/static。
- 手动指定static_url_path时，如果static_url_path为空串，url路径不必以/开头，否则相当于static_url_path=None的情况，也就是使用static_folder的目录名字。

#### static_host

~~~python
static_host = '192.168.70.48:1456'
matching_host = True
~~~

* 注意static_host必须和mathing_host搭配使用，不然会报错，源码断言错误。



### 9、Flask中的run方法

* debug参数
* host参数
* port参数

#### debug调试模式

作用：可以重启服务器；可以打印错误信息（当代码执行错误，在前端访问页面时会直接输出错误日志）

注意：不要在生产环境上使用调试模式，会遭到攻击。



#### host

使其他网络能够访问：0.0.0.0外部访问

固定的网络地址：192.168.1.23指定固定的网络地址

用python开启flask web服务时，

（1）你只需要本机访问，那ip只要不设置为0.0.0.0就可以，正常访问就好

（2）如果你需要外网访问，ip需要设置为0.0.0.0，此时，在本机上访问需要使用默认的127.0.0.1（也就是你不设置ip时默认的ip）,在外网上访问则需要使用你本机的ip，不要使用0.0.0.0



#### if `__name__ = __main__`

**Flask中的run方法要写在main方法下**

* 只有当该文件本身执行时才会运行这行代码
* flask在生产环境中不会使用run方法，一般是用uwsgi+nginx这样组合。flask实际上是作为一个模块传给uwsgi，如果又if main，app.run()不会执行，但是如果不写在main下就会启动两个服务。

#### **源码解析**

run方法使用的时werkzeug里的run_simple(host, port,self, **options)方法。最后执行的时SharedDataMiddleware的call方法。





### 10、配置项config

#### 配置项的实现方式

* 使用\*\*.ini、\*\*.yaml文件进行配置
* 利用python的数据类型进行配置：字典dict **key:value**  不可变字典immutable_dict
* 利用类不同的属性来储存配置，setattr、getattr
* Flask中使用Config文件来储存配置项——from flask import Config
  * 设置配置项：app.config['DEBUG']=True;app.config['port']=5002



host和port等都可以在run里指定参数，但是他们也可以通过配置项/配置文件的形式来修改。

#### 配置文件的重要性

如果现在项目要部署给别人使用，debug这样的东西就要关了。port也有可能需要修改，那是不是要上线以后再手动去修改呢？？？

不行。通过配置文件，不同环境我们使用不同的配置文件就可以了



## 三、路由

### 1、多URL的路由（视图装饰器）

一个函数上可以设置多个url路由规则。用视图装饰器实现

~~~python
@app.route('/')  # 视图装饰器
@app.route('/hello/')
@app.route('/hello/<name>')
def hello(name=None):
    if name is None:
        name = 'world'
    return 'hello %s' %name
~~~



##### 其他装饰器如何装饰视图函数

* 其他装饰器放在视图装饰器最里面，否则其他装饰器不会生效。

* 其他装饰器不要return其他值，只能return回视图函数的返回值。否则return的其他值会被包装正响应对象返回给前端。

~~~python
# 其他装饰器
def log_time(f):
	def swapper(*args, **kw):
		print(f'{time.time()})
        return f(*args,**kwargs)  # 不要return其他内容，否则会被作为reponse返回给前端
    return swapper

@app.route('/')
@ap.route('/hello/')
@log_time
def get_projects(p_id=7):
	return f'hello {p_id}'
~~~



视图函数用来存储访问数据

~~~python
def log_time(f):
	def swapper(*args,**kw):
		app.config['num'] +=1
		return f(*args, **kw)
	return swapper
~~~



### 2、路由的动态参数

#### 视图函数获取动态参数的方式

* 将动态参数写到URL的地址中去，以供视图函数获取
* 将动态参数以参数的形式写到URL中？后面，以供视图函数获取

~~~python
@app.route('/user/<user_name>')  # 将参数写到url地址中
def login(user_name)
	return user_names
~~~

#### 参数可接受的数据类型

@app.route('/user/`<int:user_name>`')

* string：不能包含“/”
* path：可以包含“/”
* int：整型数据类型
* float
* uuid：特定格式的字符串，通常用来生成唯一的ID
  * print(uuid.uuid4())——fa27d525-c97c-4fe4-a7e3-a3156c97f2cd



### 3、路由重定向

#### 比较访问/hello和/hello/的区别

```python
flask哲学，/cases/和/cases/ 是两个不同的URL
```

在浏览器里输入/hello会无法访问

当路由设置为/hello/后就可以访问了

解决方案：@app.route('/hello/')

#### 重定向

通过浏览器F12观察访问/hello 和/hello/ 的区别。/hello进行了两次请求，重定向了/hello到/hello/

**唯一URL原则**

* 从逻辑上来讲这样是不合理的。我同样一个逻辑，你为什么要给我搞两个地址？
  * 对SEO有好处，两个URL会被索引两次。重复内容降权到底是后面加还是不加呢？加可以兼容，不加就报错。



![image-20211023090948839](Python测试开发.assets/image-20211023090948839.png)

### 4、路由注册机制

#### 注册方式

* 装饰器注册
* 集中注册app.add_url_rule(路由地址，视图函数名)

访问URL触发对应的视图函数。函数是没有主动调用的，在哪里使用呢？
之前的最小服务器示例。
保存在se1f.ur1_map（）

装饰器注册源码解析：

~~~python
def route(self, rule: str, **options: t.Any) -> t.Callable:
	def decorator(f: t.Callable) -> t.Callable:
       endpoint = options.pop("endpoint", None)
       self.add_url_rule(rule, endpoint, f, **options)  # 实际上也是集中注册，只不过封装了一下
       return f

return decorator
~~~

源码阅读app.add_url_rule('/hello/'， view_func=index)



#### app.url_map

路由的定义：将URL和视图函数的绑定关系统称为路由

端点的定义：将每一个路由（即每一个绑定关系）称为一个端点

app.url_map是用来存储每一个绑定关系的。类似字典形式存储。



### 5、app.route()可配置参数

**app.route()的option参数使用了werkzeug的Rule类。**

* endpoint进行URL构建的时候会有用。endpoint的作用是在url和view中间设置一个桥梁。 
* emthods，默认有get,head,option
* redirect_to，重定向
  * 方法一：在注册路由时进行重定向，@app.route(redirect_to='/')，此种方式重定向不会执行该路由下的视图函数。
  * 方法二：通过在视图函数下方return redirect(重定向的url)。此种方法会执行该视图函数，且redirect需要导入方法。

* defaults（），只一个默认参数值

  * 方法一：@app.route('/', defaults={'id':3})

  * 方法二：直接在视图函数中指定默认参数和值

    def hi(id=3):

    ​	pass



### 视图函数的分离（大型项目）

随着项目的增大，我们想要把视图函数单独放在一起。不写在一个文件里了。所以我们的架构变成了
启动文件

视图函数

数据处理

view

其他的帮助函数





客家话

### 2、装饰器

* 函数可以在自己内部再定义另外函数。当调用外层函数时，内部定义的函数同时也会被调用。
* 内部定义的另外函数不能再函数外部被访问





## 四、视图函数

### 一、视图函数的形式

分请求方法

分请求单复数

视图函数对应MVC的部分，不要越界



### 二、基于类的视图



#### 可插拔视图

##### 1、实例

可插拔视图是基于类的视图。

注意，可插拔视图里的视图函数的路由必须通过集中注册的方式进行注册。

实例

~~~python
from flask.views import View
app = Flask(__name__)

class UserView(View):
	methods = ['GET', 'POST']  # 用来定义支持前端的请求方法
	
	def dispatch_request(self):  # 可插拔视图里的固定方法。用来分配请求
		return '{}到hello'.format(request.method)

app.add_url_rule('/', view_func=UserView.as_view('user'))

~~~

##### 2、不同的请求进行不同的处理

~~~python
from flask import Flask, request
from flask.views import View

app = Flask(__name__)

class ProjecView(View):

    # methods = ['GET', 'POST']  # 限制浏览器请求方法的第二种方式

    def get(self):
        return 'get'
    def post(self):
        return 'post'


    #分配请求， 将不同的请求方式分开处理，不在同一个视图中处理
    def dispatch_request(self):  # 视图类中固定的方法，专用于处理请求。
        dispatch_pattern={'GET':self.get, 'POST':self.post}
        method = request.method
        return dispatch_pattern.get(method)()



f = ProjecView.as_view('project')
log_time(f)  # 装饰器装饰函数的第二种调用方式。显示调用。

app.add_url_rule('/project', view_func=f, methods=['GET', 'POST'])  # 将类ProjectView通过函数和as_view方法当作视图函数来使用
# as_view需要一个参数，即这个视图的名称。
# 限制允许请求的请求方式一

if __name__ == '__main__':
    app.run(debug=True)
~~~

#### method_view

method_view也是类视图的一种

~~~
from flask import Flask,request
from flask.views import View, MethodView

# methoView也是类视图的一种
app = Flask(__name__)

class UserView(MethodView):
    # methods = request.method  不需要再去调用前端的请求方法来分配不同的请求了。
    # 使用method_view后，会自动获取请求方法，然后进行分发请求。
    # methodView视图也不需要重写dispatch_request方法。父类MethodView中已经封装重写了。

    def get(self):
        return 'get'
    def post(self):
        return 'post'
    def put(self):
        return 'put'

app.add_url_rule('/', view_func=UserView.as_view('userview'))  # 使用method_view视图，默认支持所有的常见的请求方式。
# 一般默认情况下，被允许前端请求的方式get

if __name__ == '__main__':
    app.run(debug=True)
~~~





#### 装饰器装饰类视图

* 不能直接在视图类上添加装饰器
* 不能直接在方法上添加装饰器

* 类视图不能用”@函数名“来装饰、
* 因为本质上装饰的是视图函数。而`UserView.as_view(视图名称)`就把视图类转化成了视图函数，所以装饰时只需要装饰这一行代码就可以了。

##### 类视图被装饰的第一种方法

* 直接显性调用装饰器

~~~python
from flask.views import View
app = Flask(__name__)

def log_time(f):
    def one(*args, **kwargs):
        print(f'{time.time()}')
        return f(*args, **kwargs)
    return one


class UserView(View):
	methods = ['GET', 'POST']  # 用来定义支持前端的请求方法
	
	def dispatch_request(self):  # 可插拔视图里的固定方法。用来分配请求
		return '{}到hello'.format(request.method)

f = UserView.as_view('user')  # 相当于视图函数。
log_time(f)  # 显性调用装饰器装饰
app.add_url_rule('/', view_func=f)
if __name__ == '__main__':
    app.run(debug=True)

~~~

##### 类视图被装饰的第二种方法

~~~python
from flask.views import View
app = Flask(__name__)

def log_time(f):
    def one(*args, **kwargs):
        print(f'{time.time()}')
        return f(*args, **kwargs)
    return one


class UserView(View):
	methods = ['GET', 'POST']
    
    decorators = (log_time,)
	
	def dispatch_request(self): 
		return '{}到hello'.format(request.method)

f = UserView.as_view('user')
app.add_url_rule('/', view_func=f)
if __name__ == '__main__':
    app.run(debug=True)

~~~



##### 类试图的优点

主要用在前后端分离的情况下。前后端不分离时，视图函数不仅仅需要处理逻辑还需要处理前端的模板。前后端不分离主要用函数形式的视图函数。前后端分离主要用类视图的形式。

* 类视图是可以继承的
* 类视图代码可以复用
* 可以定义多种行为（方法）
* 一个类试图能够支持不同的请求方式，get post put delete。而普通的函数形式的视图，对于不同请求方式，需要写不同的视图函数。





## 五、请求和响应

### 一、请求

获取前端传过来的请求数据时后端服务来管理的，Flask内置request来管理。使用from flask import request 导入。

#### 1、Ajax请求

见代码

#### 2、request的参数

* request.method：保存前端的请求方式

* request.form：form表单中传递过来的值，使用request.form中拿到（post）

* request.args：保存的是url中传递的参数（get）

* request.args与request.form的区别就是：
  * request.args是获取url中的参数，request.form是获取form表单中的参数
  
  
  
* request.json：保存请求头为application/json格式的数据（post、put）

  * requst.json源码实际调用的时get_json()方法，get_json(force=False)，force参数代表是否进行强制转换。

    有时请求头中并没有设置application/json，但是实际发送到服务端的信息确实时json格式的。此时可以在后端直接调用get_json方法将数据强制转化成json格式。

    

* request.is_xhr：用于判断是否是Ajax请求。新flask版本已经弃用。

* request.is_json：用于判断是否是发送的json数据格式

**其他参数**

* request.values：类型CombinedMultiDict，同时存储formdata数据和URL中的数据

* request.cookies：存在浏览器端的字符串一起带过来，前提是要开启浏览器中的cookies，类型是dict

* stream：在可知的mimetype下，如果进来的表单数据无法解码，会没有任何改动的保存到这个stream以供使用。很多时候，当请求的数据转换为string时，使用data是最好的方式。这个stream值返回数据一次。

* request.headres ：用来获取本次请求的请求头，字典类型

* request.data： 如果数据类型是flask无法处理的mime type，flask就会将数据变成字符串存在data里

* request.files：文件上传的功能，里面存的是上传的文件。通过post或put请求上传的文件

  ~~~html
  <!--发起文件上传的前端页面-->
  <form action="/req" method="post" enctype="multipart/form-data">
      <input type="file" name="demo">
      <input type="submit">
  </form>
  ~~~

  

  ~~~python
  # 后端写法
  print(request.files)  # ImmutableMultiDict([('file', <FileStorage: 'DragonFire.txt' ('text/plain')>)])
  print(request.files["set_for_if_flash"])  # <FileStorage: 'DragonFire.txt' ('text/plain')>
  my_file = request.files["set_for_if_flash"]
  my_file.save("OldBoyEDU.txt")  # 保存文件,里面可以写完整路径+文件名
  ~~~

* remote_addr：获取远程IP，可以限制IP的行为
* user-agent：提供反扒和恶意攻击
* 通过request获取请求路径：
  * 获取当前的url路径request.path	# /req
  * 当前url路径的上一级路径 request.script_root	 #
  * 当前url的全部路径  request.url 	# http://127.0.0.1:5000/req
  * 当前url的路径的上一级全部路径  request.url_root  	# http://127.0.0.1:5000/
* request.environ：wsgi隐含的环境配置，requset下的所有属性都是从这个属性中封装出来的。

**注意request.属性的返回值全是类字典格式的，可以通过字典形式获取key-value。也可以利用request.属性.to_dict()方法将类字典格式转化为纯字典格式**



#### 3、文件上传

##### 1、样例

前端代码

~~~ html
<form action='http://localhost:5000/upload' method='post' enctype='multipart/form-data'>
	<input type='file' name='f'>
	<input type='submit'>
</form>
~~~

**注意：一定要加enctype="multipart/form-data"，不然浏览器不会上传**



后端代码

~~~python
@web.route('/upload', methods = ['GET', 'POST'])
def index():
	r = request.files['f']
	r.save(r.filename)
	return ('successful')
~~~



**如果要使用文件原来的名字，用secure_filename**

from werkzeug.utils import secure_filename，需要导入方法

~~~python
@app.route('/upload', methods=['GET', 'POST'])
def upload():
	if request.method=='GET':
		return render_template('upload.html')
	file = reqeust.files.get('fso')
	path = os.getcwd()
	file.save(path+secure_filename(file.filename))  # secure_filename()方法必须要用
	return 'upload'
		
~~~



##### 2、限制文件大小

~~~python
app.config['MAX_CONTENT_LENGTH']=10*1024*1024

~~~



##### 3、限制文件格式

~~~python
# 限制上传文件的格式
def allowed_format(filename):
    format_list = ['jpg', 'npg', 'md', 'gif']
    file_format = filename.split('.')[-1]
    if file_format in format_list:
        return True
    return False
~~~



##### 4、让文件可以被访问

* 方法一

  将文件保存到flask项目下的static目录里

~~~python
return redirect(url_for('uplaoded', filename=new_name))
~~~



* 方法二

  将文件保存到任何方便管理的路径下

  flask提供了send_from_directory（）方法，去找寻相关文件，然后作为服务传递给前端.

~~~
@app.route("/load/<filename>", methods=['GET'])
def load(filename):
	return send_form_directory(os.getcwd(), filename)
~~~



### 二、响应

如果不进行任何设置，返回字符串浏览器会在自动把它变成HTML

#### 1、主要的响应类型content-type

响应的content-type体现的响应头中:	文本 -- text/plain	html -- text/html	xml -- application/xml	json -- application/json



#### 2、常用的mimetype类型

**媒体类型**（通常称为 **Multipurpose Internet Mail Extensions** 或 **MIME** 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式。

重要：浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理URL，因此Web服务器在响应头中添加正确的MIME类型非常重要。如果配置不正确，浏览器可能会曲解文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。

一、常用类别格式: type/subtype

　　　MIME的组成结构非常简单；由类型与子类型两个字符串中间用`'/'`分隔而组成。不允许空格存在。*type* 表示可以被分多个子类的独立类别。*subtype 表示细分后的每个类型。*MIME类型对大小写不敏感，但是传统写法都是小写。

| 类型          | 描述                                                         | 典型示例                                                     |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `text`        | 表明文件是普通文本，理论上是人类可读                         | `text/plain`, `text/html`, `text/css, text/javascript`       |
| `image`       | 表明是某种图像。不包括视频，但是动态图（比如动态gif）也使用image类型 | `image/gif`, `image/png`, `image/jpeg`, `image/bmp`, `image/webp`, `image/x-icon`, `image/vnd.microsoft.icon` |
| `audio`       | 表明是某种音频文件                                           | `audio/midi`, `audio/mpeg, audio/webm, audio/ogg, audio/wav` |
| `video`       | 表明是某种视频文件                                           | `video/webm`, `video/ogg`                                    |
| `application` | 表明是某种二进制数据                                         | `application/octet-stream`, `application/pkcs12`, `application/vnd.mspowerpoint`, `application/xhtml+xml`, `application/xml`, `application/pdf` |



#### 3、构造响应的两种方式

##### 1、直接return返回

第一直接return返回响应内容、状态码、响应头信息。注意顺序不能变。

~~~python
@app.route('/')
def register():
    return 'hello world',201,{'content-type':'text/plain','server':'测试开发'}
			响应内容	  状态码  			响应头相关的信息  
~~~

注意：响应内容是必须返回的，状态码和响应头可以任意指定或者不指定。

##### 2、利用make_response来构造响应

make_response(响应数据， 响应状态码， 响应头)。位置参数的顺序不能错。**实际上是使用的Response()类来创建的。也可以直接利用Response()来创建响应**

**make_response有两种方式构造**

* 第一种，直接初始化构造make_response对象

~~~python
a = json.dumps({'user':'yeze'})
b = make_response(a,	201,	headers={'x':'wofo'})
				  响应内容   响应状态码	响应头的相关信息
                  
                  
# 然后return返回b即可
~~~



* 第二种，先定义再初始化构造make_response对象

  Response中的几个常见属性

  1. headers：请求头相关
  2. status : String类型的数据，格式例如：“200 ok”
  3. status_code : int 类型，状态码，不能是自定义的状态码
  4. data : 需要返回到前端的数据
  5. set_cookie() ：设置cookie 的值
  6. del_cookie() ：删除cookie

~~~python
a = json.dumps({'user':'yeze'})
b = make_response()
b.response = a
b.status = '201'  
b.headers = {'x':'wofo'}

# 然后return返回b即可
~~~



#### 4、json响应格式

* **json的响应格式，响应数据的key和value字符串必须用"双引号。**



##### 1、json.dumps()

* 将字典格式数据直接转化成json格式字符串返回至前端

~~~python
@app.route('/')
def register():
	return json.dumps({'msg':'hello'})  # 此时前端浏览器收到的响应格式并不是application/json的，因为没有指定响应头的content-type
~~~

添加格式

~~~python
@app.route('/')
def register():
	return json.dumps({'msg':'hello'}), 200, {'content-type':'application/json'}
	
~~~



##### 2、jsonify()

jsonify不仅仅将字典格式数据转化成了json格式的字符串，另外给响应头content-type设置成了json

注意jsonify不能同时有位置参数和关键字参数的

~~~
@app.route('/')
def register():
	return jsonify({'msg':'hello'})
~~~

**jsonify指定响应状态码**

~~~python
@app.route('/')
def register():
	return jsonify({'msg':'hello'}), 200
~~~



~~~python
@app.route('/')
def register():
	r = jsonify({'msg':'hello'})
	r.status = 201
	return r
~~~



#### 5、响应中文

无论是使用json.dumps()还是jsonify()，返回中文字符时的原生格式都不会直接显示中文

~~~python
@app.route('/')
def register():
	return json.dumps({"msg":"你好"})
~~~

~~~python
{“msg":"\u4f60\u597d"} #浏览器显示情况。只有经过浏览器美化才会显示中文。谷歌浏览器没有美化，需要设置参数，才能显示
~~~

* 直接设置参数ensure_ascii

~~~python
return json.dumps({"msg":"你好"}， ensure_ascii=False)
~~~

* 或者通过配置项实现

~~~python
app.config('JSON_AS_ASCII')=False
@app.route('/')
def register():
	return jsonify({"msg":"你好"})
~~~



#### 6、返回响应总结

* 在flask中你想向前端返回数据，必须是`Response`的对象

* from flask import Flask,Response,make_response

* [链接]: https://blog.csdn.net/sa726663676/article/details/117437546

  

解决方案：

* **return直接返回**
* **make_response+return返回。**（可以结合render_template）
* **Response+return返回。**（可以结合render_template）
* **jsonify+return返回**。
* **render_template+return返回**



### 三、请求和响应差异点

#### 1、请求头与响应头中Content-Type有何不同？

Request Headers下的Content-Type是客户端对服务器约定的编码格式，服务器要按照对应格式解码；

反之，Response Headers下的Content-Type是服务器对客户端约定的编码格式，客户端要按照对应格式解码。



#### 2、HTTP报文头Accept和Content-Type总结

Accept代表发送端（客户端）希望接受的数据类型。

Content-Type代表发送端（客户端|服务器）发送的实体数据的数据类型。



### 四、重定向redirect

#### 1、redirect

重定向有两种方式

* redirect("/new/url")
* redirect(url_for("endpoint"))
  * url_for(端点名)，url_for函数作用，通过传入的端点名称构造一个URL出来

**使用url_for的形式进行重定向更好， url_for可以添加参数**

~~~python
from flask import Flask, redirect, request, url_for
from werkzeug.routing import Rule

app = Flask(__name__)

@app.route('/', methods=['GET', 'PSOT'])
def index():
    if request.args.get('username') is None:
        # redirect 中使用url_for(endpoint名, **values) 进行重定向，values参数是路由规则(Rule类from werkzeug.routing import Rule)中的参数
        return redirect(url_for('hhh', username='panda', pwd='dog'))
        # url_for在重定向时可以添加关键字参数，添加测关键字参数是重定向至URL的参数，原路由没有关系。
        # 此重定向后，前端访问“127.0.0.1:5000/”，则会重定向至“http://127.0.0.1:5000/login?username=panda&pwd=dog”
    return 'hello'

@app.route('/login', methods = ['GET'], endpoint='hhh')
def login():
    return 'login'
~~~

#### 2、url_for()

**1.url_for()作用:**
(1)给指定的函数（端点）构造 URL。
(2)访问静态文件(CSS / JavaScript 等)。 只要在你的包中或是模块的所在目录中创建一个名为 static 的文件夹，在应用中使用 /static 即可访问。

**1.1给指定的函数构造 URL:**
它接受函数名（端点名）作为第一个参数，也接受 URL 规则中对应的变量作为参数。未知变量部分会添加到 URL 末尾作为查询参数。

~~~python
from flask import Flask, url_for
app = Flask(__name__)
@app.route('/')
def index(): pass
 
@app.route('/login')  # 此处装饰器中没有指定视图函数的端点，所以默认endpoint=视图函数名称
def login(): pass
 
@app.route('/user/<username>')
def profile(username): pass
 
with app.test_request_context():
print(url_for('index'))  # /
print(url_for('login'))  # /login
 
#将未知变量next添加到 URL 末尾作为查询参数
print(url_for('login', next='/'))  # /login?next=/
 
# 将 URL 规则中对应的变量 username 作为参数
print(url_for('profile', username='JohnDoe'))  # /user/JohnDoe
~~~



### 五、错误响应

#### 1、对于不可预知的错误

自定义500：

~~~python
@app.errorhandler(500)
def error_500(error):
	return '现在服务器有问题，500，稍后重试'
~~~



#### 2、对于可以预知的错误

##### 1、return

~~~python
@app.route('/')
def index():
	if not request.args.get('username'):
		return make_response('<p> 401 没有授权 <p>', 401)
	return 'hello, welcome to my world'

~~~

##### 2、abort函数（抛出指定的异常）

~~~python
@app.route('/')
def index():
	if not request.args.get('username'):
		abort(401)
	return 'hello, welcome to my world'
~~~

##### 3、自定义错误，然后抛出raise

~~~python
class NotLoginException(Exception):
    pass

@app.errorhandler(NotLoginException)
def api_401(error):
    return json.dumps({"msg":"not login"}), 401, {"content-type":"application/json"}

@app.route("/")
def index():
    if not request.args.get('username'):
        raise(NotLoginException('not login'))
    return 'index'
~~~





## 六、模板引擎

### 一、模板快速渲染

渲染一个模板，在flask中使用render_template()方法即可

~~~python
@app.route('/')
def index():
  # return render_template('about.html',user='username')  
  return render_template('about.html',**{'user':'username'})  # 变量user，在html模板中可以通过{{ user }}直接获取使用
~~~

- `{{ ... }}`：装载一个变量，模板渲染的时候，会使用传进来的同名参数这个变量代表的值替换掉。
- `{% ... %}`：装载一个逻辑控制语句。
- `{# ... #}`：装载一个注释，模板渲染的时候会忽视这中间的值。



### 二、静态文件

在模板引用静态文件

~~~html
<link rel="stylesheet" href="{{url_for('static', filename='demo.css')}}"

p{
	color:red
}
~~~



### 三、变量属性

在模板中设置变量，并引用变量的值/属性

~~~jinja2
模板中设置变量
{% set a = "panda" %}
模板中引用变量
{{ a }}
~~~



~~~jinja2
后端设置数据，并通过render_template渲染到模板中
user={'name':'panda', 'age':18}

模板中使用变量,获取变量属性
{{ user.name }}
{{ user['name'] }}

{% set a=user.name %}
引用变量a
{{ a }}
~~~



### 四、for循环

~~~jinja2
{% for p in projects %}
项目： {{ p.name }} : {{ p.interfaces }}
{% endfor %}
~~~

默认每个for循环得到的元素之间有空白，如果要去除空白，使用`-`

~~~jinja2
{% for p in projects -%}
项目： {{ p.name }} : {{ p.interfaces }}
{%- endfor %}
~~~



for循环内置常量：例如 {{ loop.index }}

| 变量           | 描述                                |
| -------------- | ----------------------------------- |
| loop.index     | 当前循环迭代的次数（从1开始）       |
| loop.index0    | 当前循环迭代的次数（从0开始）       |
| loop.revindex  | 到循环结束需要迭代的次数（从1开始） |
| loop.revindex0 | 到循环结束需要迭代的次数（从0开始） |
| loop.first     | 如果是第一次迭代，为True            |
| loop.last      | 如果是最后一次迭代，为True          |
| loop.length    | 序列中的项目数                      |
| loop.nextitem  | 获取下一个项目                      |





### 五、if条件

~~~jinja2
{% if p.name == 'panda' %}
***

{% elif p.name == 'demo' %}
***

{% endif %}
~~~



### 六、消息闪现

flask端：

~~~python
flash("you have many projects")
~~~

jinja2:

~~~jinja2
{% set msg = get_flashed_messages() %}
{{ msg }}
~~~

flash源码：实际是把flash数据添加到session里面。再定义个全局函数去获取。



注册的例子：

~~~python
@app.route("/login/", methods=["GET", "POST"])
def login():
	if request.method == 'POST':
		username = request.form.get('user')
		pwd = request.form.get('pwd'):
		if not all([username, pwd]):
			flash('请输入账号或密码')
		elif username != 'yuze' and pwd != '1234'
	return render_template('demo_flash_msg.html')
			
~~~



jinja:

~~~jinja2
{% set msg = get_flashed_messages() %}
{% for m in msg %}
{{ m }}
{% endfor %}
登录
<form action="/login/", method="post">
	<input name="user">
	<input type="password", name="pwd">
	<input type="submit">
</form>
	
~~~





### 七、可以在模板中访问的全局变量和函数

注意：以下的变量均是后端实现的功能，同时在模板中也可以访问这些变量和函数。

* session，在服务端用于保存客户端传到后台的数据，类字典的形式
* request，flask中的request
* g，在同一次请求之间共享数据
  * 每一次请求结束会重置g这个全局变量。。若要在不同请求之间共享数据可以用session来实现。
* config，flask中的配置项。通过修改后端中config配置项，就可以直接更改模板中展示的效果，而不需要修改前端模板中的代码。
* url_for()
* get_flashed_messages()，消息闪现

~~~jinja2
<body>
	{{ session }}
	{{ request }}
	{{ g }}
</body>
~~~





### 八、URL反向构建

1、反转通常比硬编码的URL的描述性更好

2、你可以只在一个地方改变URL，而不用到处乱找

3、URL创建会为你处理特殊字符的转义和Unicode数据，比较直观

4、生产路径总是绝对路径，可以避免相对路径产生副作用

5、如果你的应用是放在URL根路径之外的地方（如在/myappliction中，不在/ 中），url_for()会为你妥善处理

~~~HTML
<form action="{{ url_for('login') }}", method="post"
~~~



### 九、过滤器

#### 一、管道命令过滤器

##### 1、字符串

~~~jinja2
{# 当变量未定义时，显示默认字符串，可以缩写为d #}
{{ name | default('No name', True) }}

{# 单词首字母大写 #}
{{ 'hello' | capitalize }}

{# 单词全小写 #}
{{ 'XML' | lower }}

{# 去除字符串前后的空白符 #}
{{ '    hello    ' | trim }}

{# 字符串反转，返回“olleh” #}
{{ 'hello' | reverse }}

{# 格式化输出，返回“number is 2” #}
{{ '%s is %d' | format("Number", 2)}}
~~~





~~~jinja2
{# 关闭HTML自动转义 #}
{{ '<em>name</em>' | safe }}

{% autoescape false %}
{# HTML转义，即使autoescape关了也会转义，可以缩写为e #}
{{ '<em>name</em>' | escape }}
{% endautoescape %}
~~~





##### 2、数字

~~~jinja2
{# 四舍五入取整，返回13.0 #}
{{ 12.888 | round }}

{# 向下截取到小数点后两位，返回12.88 #}
{{ 12.888 | round(2，'floor') }}

{# 绝对值，返回12 #}
{{ -12 | abs }}
~~~





##### 3、列表

~~~jinja2
{# 取第一个元素 #}
{{ [1,2,3,4] | first }}

{# 去最后一个元素 #}
{{ [1,2,3,4] | last }}

{# 返回列表长度，可以写为count #}
{{ [1,2,3,4] | length }}

{# 列表求和 #}
{{ [1,2,3,4] | sum }}

{# 列表排序，默认为升序 #}
{{ [3,4,5,1,2] | sort }}

{# 合并为字符串，返回“1|2|3|4|5” #}
{{ [3,4,5,1,2] | join('|') }}

{# 列表中所有元素全都大写，这里可以用upper，lower，但是capitalize无效 #}
{{ ['tom','bob','ada'] | upper }}
~~~





##### 4、tojson

~~~
{{ user | tojson | safe(0,10前) }}
~~~



#### 二、注册自定义过滤器

方法一：装饰器

~~~python
@app.template_filter()
def file_format(filename):
	split = filename.rsplit('.',1)
	if len(split) <= 1:
		return filename
	return split[1]
	
{{ filename | file_format}}
~~~





方法二：更集中的注册

~~~
app.jinja_env.fileters['file_format'] = file_format
app.add_template_filter(函数名, 过滤器名称)
~~~

实际上，装饰器还是去调用方法二





### 十、测试

* 主要用来做判断的

除了过滤器，所谓的“测试”也是可用的。测试可以用于对照普通表达式测试一个变量。

要测试一个变量或表达式，你要在变量后加上一个is以及测试的名称。例如，要得出一个值是否定义过，你可以用 `name is defined`，这会根据name是否定义返回true或false。

测试也可以接受参数，如果测试只接收一个参数，你可以省去括号来分组他们。例如下面的两个表达式做同样的事情。

~~~jinja2
{% if loop.index is divisibleby 3 %}
{% if loop.index is divisibleby (3) %}
~~~





#### 一、内置测试器

~~~jinja2
{# 检查变量是否被定义，也可以用undefined检查是否未被定义 #}
{% if name is defined %}
	Name is : {{ name }}
{% endif %}

{# 检查是否所有字符都是大写 #}
{% if name is upper %}
	"{{ name }}" are all upper case.
{% endif %}

{# 检查变量是否为空 #}
{% if name is none %}
	variable is none 
{% endif %}

{# 检查变量是否为字符串，也可以用number来检查是否为数值 #}
{% if name is string %}
	{{ name }} is a string
{% endif %}

{# 检查数值是否为偶数，也可以用odd检查是否为奇数 #}
{% if 2 is even %}
	Variable is an even number
{% endif %}

{# 检查变量是否可被迭代循环，也可以用sequence检查是否是序列 #}
{% if [1,2,3] is iterable %}
	Variable is iterable
{% endif %}

{# 检查变量是否是字典 #}
{% if {'name':'test'} is mapping %}
	Variable is dict
{% endif %}
~~~



#### 二、自定义测试器

~~~python
# 自定义一个测试，用来判断数据是否为json格式
@app.template_test()
def jsoned(my_str):
    try:
        json.loads(my_str)
        return True
    except ValueError:
        return False
        
~~~



~~~jinja2
{% if test_json is jsoned %}
{{ test_json }}
{% else %}
not a json
{% endif %}
~~~





### 十一、context_processor环境处理器

比如：全局变量g，session等并没有通过render_template返回至前端模板中，但是依然可以使用这些变量、函数等，实际上都是环境处理器上下文在起作用。

* 主要用来定义一些全局可以访问的变量和方法函数

#### 1、传递变量

~~~python
@app.context_processor
def project_number():
	return {"project_num":4}
~~~



函数用`@app.context_processor`装饰器修饰，它是一个上下文处理器，它的作用是在模板被渲染前运行其所修饰的函数，并将函数返回的字典导入到模板上下文环境中，与模板上下文合并。

#### 2、传递函数

~~~python
@app.context_processor
def add_funtion():
	def format_file(filename):
		split = filename.rsplit('.',1)
		if len(split) <= 1:
			return filename
        return split[1]

	def get_project(user):
    	return "4 of user: {}".format(user)
	return dict(format_file2=format_file, get_project2=get_project)  # 以字典的形式返回方法和变量

# 模板
{{ format_file2('demo.pdf') }}
{{ get_project2('panda') }}

# 动态获取数据
{{ format_file2(file) }}
{{ get_project2(user) }} # 参数在view_fun 传递
~~~

* 注意：返回的内容需要是一个字典形式让模板去获取。传递函数会发现和过滤器的作用又有所重复，但是当要操作多个变量的时候这个函数会更有优势。



### 十三、全局函数

前面的都是在上下文环境中添加，全局函数是完完全全的一个全局的。随时都可以用的，用法和全局变量一样。

使用方法和context_processor一样，只不过全局函数的注册器为@app.template_global，装饰器不用加参数

~~~python
import re
@app.template_global
def accept_pattern(pattern_str):
	pattern = re.compile(pattern_str, re.s)
	
	def search(content):
        return pattern.findall(content)
    return dict(search=search, current_pattern=pattern_str)

app.add_template_global(accept_pattern, 'accent_pattern')  #参数1-被装饰的函数，参数2-自定义名称
~~~



### 十四、继承、宏、include

#### 继承

* 继承父模板

基模板

~~~html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>测试开发 - {% block title %}{% endblock %}</title>
</head>
<boday>
	你好，欢迎来到测试开发！
	<p>这里是你的信息</p>
	<hr>
	{% block content %}
	这里是变化的内容，自定义的内容
	{% endblock %}
	<hr>
	<p>页面已经结束 @copyright</p>
</boday>
</html>
~~~



子模板

~~~jinja2
{% extends "baseage.html" %}

{% block title %} demo-herit {% endblock %}

{% block content %} 变成新内容。 {% endblock %}


~~~





#### include

~~~jinja2
{% include 'demo_new_content.html' %}   {# 导入其他html模板中的代码到相应文件 #}
~~~





#### 宏（自定义函数）

~~~jinja2
{% macro render_field(field) %}   {# 关键字：macro 函数名称：render_field 参数：field #}
	{{ field.label }}
	{{ field }}
{% endmacro %}
~~~



~~~jinja2
{% from 'macros.html' import render_field %}
{{ render_field(form.phone) }}
{{ render_field(form.pwd) }}
{{ render_fiedld(form.confirm_pwd) }}
~~~





## 七、表单验证

### 一、表单传送过程

客户端发起请求》》》》flask中的request保存数据》》》》通过request.form获取数据



### 二、为什么要有参数验证

* 请求携带脚本，进行恶意攻击，删除数据库，查询敏感数据内容等
* 用户发送过来的任何数据都是不可信任的
* 判断用户信息不仅仅要从前端更要在后端进行校验



### 三、数据验证

* 写一个登录或者注册的例子
* 要数据库验证需要耗费时间的条件放到最后，越影响性能的条件越放到后面。



#### 第一种方式，直接return错误提示

~~~python
@app.route('/<phone>/pwd')
def register(phone,pwd):
	if len(str(phone)) != 11:
		return 'phone number is error'
    if not phone.isdigit():
        return 'wrong phone nubmer'
    if not phone.startswith('1'):
        return 'wrong phone number'
    if len(str(pwd))<8:
        return 'pwd need at least 8'
    if pwd.isdigit():
        return 'pwd too simple'
  	return 'welcom to python'

~~~





#### 第二种方式，利用abort中的description抛出异常错误提示

~~~python
@app.route('/<phone>/pwd')
def register(phone,pwd):
	if len(str(phone)) != 11:
		abort(412, description='phone number is error') 
    if not phone.isdigit():
    	abort(412, description='wrong phone nubmer') 
        
    if not phone.startswith('1'):
    	abort(412, description='wrong phone number') 
    if len(str(pwd))<8:
    	abort(412, description='pwd need at least 8') 
    if pwd.isdigit():
    	abort(412, description='pwd too simple') 
  	return 'welcom to python'
~~~

#### 返回中文异常

abort(412)，如果description是中文的会乱码，需要指定`content-type：text/html;charset=UTF-8`

~~~python
resp = Response('请输入电话号码'， status='412', content-type='text/html;charset=utf-8')
abort(resp)
~~~



假如前端需要后端渲染

~~~python
if not phone:
	res = Response(
		render_template('register1.html', msg='请输入密码')，status='412', content-type='text/html;charset=utf-8')
	abort(res)
~~~

需要考虑的情况：

电话号码为空；电话号码不正确；密码为空；密码长度不够等等



第三种方式：

将数据校验部分封装为函数



### 四、验证层

占用视图代码空间：都写到视图函数里面光验证代码就有十几行代码

无法复用：其他的地方如果有相同的验证逻辑又要重写一次

可读性不高：其他的人要一行一行的阅读



方法1：提取函数

方法2：这个模块是专门用来处理视图的，验证应该放在其它专门的地方



### 五、WTForms

* 表单验证的一种工具

#### 1、安装

~~~python
pip install flask-wtf
pip install -U wtforms

from flask_wtf import FlaskForm

# Form 很快就要被移除了
from flask_wtf import Form
~~~



#### 2、快速使用

* 自定义一个表单类，继承wtforms.FlaskForm
* 定义好需要验证的字段，字段名必须和表单中需要验证的字段的name属性值保持一致
* 在需要验证的字段上，指定需要验证的数据类型
* 在相关字段上，指定验证器
* 在视图中，使用这个表单类的对象，并且把需要验证的数据：request.form传给这个表单类，然后调用form.validate()方法，如果返回True，说明验证通过，如果返回False，说明数据有问题，具体问题可以通过form.errors来获取

##### 定义验证器

~~~python
class RegisterForm(FlaskForm):
	# 字段名最好和表单name属性一致，最好和数据库里面的字段名一致
	phone = StringField(validators=[Regexp(r'1[3,5,8]\d{9}$), DataRequired()])
	pwd = PasswordField(validators=[Length(6,32), DataRequired()])
	confirm_pwd = PasswordField(validators=[EqualTo('pwd')])
	
# 数字校验
class SearchForm(FlaskForm):
	page = IntegerField(validators=NumberRange(min=0, max=1000))
~~~



##### 服务端l调用验证器

~~~python
import RegisterForm
app.config['SECRET_KEY'] = os.urandom(24)

@app.route("/login", methods=['GET', 'POST'])
def login():
	form = RegisterForm(fromdata=request.form)
	if form.validate():
		return render_template('注册成功')
	return render_template('hello.html', form=form)
~~~



##### flask中设置secret_key

* 前后端需要进行前后端数据交互，表单验证时需要设置密钥
* 当视图函数中需要调用验证器进行数据校验时，需要在app中设置

~~~python
app.config['SECRET_KEY'] = '随意字符串'

或者利用os.urandom(字节位数)进行构造

app.config['SECRET_KEY'] = os.urandom(24)
~~~



##### Form初始化数据

formdata：请求里的content-type是application/x-www-form-urlencoded，用来接收form表单形式的数据

obj：

data：字典形式的数组，用来接收json格式的数据



##### 如何验证json、Ajax数据

1、前端通过form表单提交数据

视图函数通过formdata参数接收数据

~~~python
form = RegisterForm(formdata=request.form)
~~~



2、request，发送json数据

视图函数通过data参数接收json数据

~~~python
form = RegisterForm(data=request.json)
~~~







#### 3、详情解析

##### 1、模板--表单渲染

* 通过FlaskForm类将form表单数据渲染回前端，可以利用数据构造出表单（而不用写HTML语句）

~~~html
<form action="http://localhost:5000/login/" method="post" id="login">
	{{ form.username.label }} {{ form.username }}  {{ form.username.errors }} {# 在前端展示某一个字段错误信息 #}
	{{ form.pwd.label }} {{ form.pwd }}
	<input type="submit">
    {{ form.csrf_token }}  {# csrf_token 必须添加在form标签内部 #}
</form>
~~~



##### 2、csrf_token

* csrf_token，只要利用wtforms进行表单验证，会自动进行csrf_token 验证
* 需要在templates的form标签中加入{{ form.csrf_token }}这串内容，它的作用是当我们get表单页面时，服务器返回页面的同时也会向前端返回一串随机字符，post提交时服务器会验证这串字符来确保用户是在服务端返回的表单页面中提交的数据，防止有人通过例如jquery脚本向某个url不断提交数据，是一种数据提交的验证机制。



##### 3、Field字段初始化参数：

**filters**：会对输入的参数做进一步的处理，用这个新数据去校验。

~~~
filters=[lambda x:x+'h',]
~~~

**widget**：自定义组件，几乎用不到

**render_kw**：render_kw={"class":"form-control"}用来给前端某个标签增加属性{属性名：属性值}

**default**：默认值

~~~
class SearchForm(FlaskForm):
	page = InterField(validators=[NumberRange(min=0,max=1000), default=0]) # defalut=0,代表了当form表单中page没有数据时，默认以“0”进行验证
~~~



##### 4、Field字段

对应于HTML里面的元素，后面主要时用来通过form参数渲染模板。每一种不同的类型本质上还是一个HTML格式的字符串的封装，放在widge属性里面

WTForms支持HTML字段：

| 字段类型            | 说明                                       |
| ------------------- | ------------------------------------------ |
| StringField         | 文本字段， 相当于type类型为text的input标签 |
| TextAreaField       | 多行文本字段                               |
| PasswordField       | 密码文本字段                               |
| HiddenField         | 隐藏文本字段                               |
| DateField           | 文本字段， 值为datetime.date格式           |
| DateTimeField       | 文本字段， 值为datetime.datetime格式       |
| IntegerField        | 文本字段， 值为整数                        |
| DecimalField        | 文本字段， 值为decimal.Decimal             |
| FloatField          | 文本字段， 值为浮点数                      |
| BooleanField        | 复选框， 值为True 和 False                 |
| RadioField          | 一组单选框                                 |
| SelectField         | 下拉列表                                   |
| SelectMultipleField | 下拉列表， 可选择多个值                    |
| FileField           | 文件上传字段                               |
| SubmitField         | 表单提交按钮                               |
| FormFiled           | 把表单作为字段嵌入另一个表单               |
| FieldList           | 子组指定类型的字段                         |



##### 5、Validators验证器

WTForms可以支持很多表单的验证函数：

| 验证函数     | 说明                                                    |
| ------------ | ------------------------------------------------------- |
| Email        | 验证是电子邮件地址                                      |
| EqualTo      | 比较两个字段的值； 常用于要求输入两次密钥进行确认的情况 |
| IPAddress    | 验证IPv4网络地址                                        |
| Length       | 验证输入字符串的长度                                    |
| NumberRange  | 验证输入的值在数字范围内                                |
| Optional     | 无输入值时跳过其它验证函数                              |
| DataRequired | 确保字段中有数据                                        |
| Regexp       | 使用正则表达式验证输入值                                |
| URL          | 验证url                                                 |
| AnyOf        | 确保输入值在可选值列表中                                |
| NoneOf       | 确保输入值不在可选列表中                                |



##### 6、form对象中几个重要函数

form = RegisterForm(request.form)

* form.validate()：验证主函数
* form.process()：验证数据，BaseForm里
* form.data：获取前端发送至后台所有数据
* form.errors：获取错误信息



#### 4、常见内置的Validators验证器

场景：自定义账号是否存在

~~~python
from wtforms.fields import (StringField, PasswordField, DateField, BooleanField, SelectField, SelectMultipleField, TextAreaField, RadioField, IntegerField, DecimalField, SubmitField)
from wtforms.validators import DataRequired, Length, Email，EqualTo, NumberRange

class RegisterForm(Form):
	# Text Field类型，文本输入框，必填，用户名长度为4到25之间
	username = StringField('username', validators=[Length(min=4, max=25)])
	
	# Text Field类型，文本输入框，Email格式
	email = StringField('Email Address', validators=[Email()])
	
	# PasswordField类型，密码输入框，必填，必须同confirm字段一致
	password = PasswordField('Password', validators=[DataRequired(), EqualTo('confirm', message='Passwords must match')])
	
	# Text Field类型，密码输入框
	confirm = PasswordField('Repeat Password', validators=[DataRequired()])
	
	# Text Field类型, 文本输入框，必须输入整型数值，范围在16到70之间
	age = IntegerField('Age', validators=[NumberRange(min=16, max=70)])
	
	# Text Field类型，文本输入框，必须输入数值，显示时保留一位小数
	height = DecimalField('Height(Centimeter)', places=1)
	
	# Text Field类型，文本输入框，必须输入”年-月-日“格式的日期
	birthday = DateField('Birthday', format='%Y-%m-%d')
	
	# Radio Box类型，单选框，choices里的内容会在ul标签里，里面每个项是（value值， 显示名称）对
	gender = RadioField('Gender', choices=[('m', 'Male'), ('f', 'Female')], validators=[DataRequired()])
	
	# Select类型，下拉单选框，choices里的内容会在Option里，里面每个项是（值，显示名）对
	job = SelectField('Job', choices=[
		('teacher', 'Teacher'),
		('doctor', 'Doctor'),
		('engineer', 'Engineer'),
		('lawyer', 'Lawyer')])
		
	# Select类型，多选框，choices里面的内容会在Option里，里面每个项是（value值，显示名称）对
	hobby = SelectMultipleField('Hobby', choices=[
		('swim', 'swimming'),
		('skate', 'Skating'),
		('hike', 'hiking')])
	
	# Text Area类型，段落输入框
	description = TextAreaField('Introduction of yourself')
	
	# Checkbox类型，加上default= 'checked'即默认是选择上的
	accept_terms = BooleanField('I accept the Terms of Use', default='checked', validators=[DataRequired()])
	
	# Submit按钮
	submit = SubmitField('Register')
	
	
~~~



#### 5、自定义Validators验证器

场景：项目名在数据库中已存在；手机号码在数据库中已经被注册了

第一种方法

~~~python
class ProjectInForm(FlaskForm):
	# TODO: project_name唯一性
	project_name = StringField(label='项目名称', validators=[DataReqired(), Length(max=66,min=1)])
	simple_desc = TextAreaField(label='项目描述', validators=[Length(max=512,min=0)])
	
	# 指定对应的数据库模型
	form_model = ProjectInfo
	
	def validate_name(self):
	"""验证名字是否唯一"""
		not_unique = self.form_model.query.filter_by(prject_name=self.project_nmae).first()
		if not_unique:
			raise ValidationError('项目名称已经存在')
			
# 在视图函数中调用validate_name进行判断（ProjectInForm)
~~~



第二种方法，模仿其他的validator:

~~~python
class Unique:
	"""验证数据库中是否唯一"""
	def __init__(self, db_class, db_column, msg=None):
		self.db_class = db_class
		self.db_column = db_column
		if msg is None:
			msg = "该数据在数据库中已存在"
		self.msg = msg
		
	def __call__(self, form, filed):
		not_unique = self.db_class.query.filter(self.db_column==filed.data).first()
		if not_unique:
			raise ValidationError(self.msg)
		return filed.data

# forms 验证器里面调用
project_name = StringField(label='项目名称', validators = [DataRequired(), Length(max=66, min=1), Unique(form_model, form_model.project_name)])
		
~~~



##### 实例

1、自定义手机号码格式验证器

* 主要通过模仿其他validators实现

~~~python
class Mobile(object):
	regex = re.compile('^1[3|4|5|7|8]\d{9}$]')
	
	def __init__(self, message=None):
        if message is None:
            self.message = '不是手机号码'
		self.message = message
	
	def __call__(self, form, field):
		match = self.regex.match(field.data)
		if not match:
			raise ValidationError(message)
		return match
    
# 在验证form表单时调用
phone = StringField(label='手机号码', validators = [DataRequired(), Mobile('手机号码格式不正确')])
~~~







#### 6、整体执行逻辑

~~~
在app主程序入口处通过form = RegisterForm(request.form)来获取前端传送至后台的表单数据。

form.validate()实际上通过for循环验证数据是否符合验证器的要求。

而验证器的要求则直接保存在validators中。

当validators判断失败，不符合规则，则会抛出异常被validate()捕获，返回form.errors
~~~







### 六、跨站脚本攻击（xss）

跨站脚本攻击是指在一个网站的环境中注入恶意的HTML（包括附带的JavaScript）。要防御这种攻击，开发者需要正确的转义文本，使其不能包含恶意的HTML标记。

* 不要让用户给你传HTML，JS
* 脚本，对文本进行正确的转义



### 七、CSRF跨站请求伪造

![image-20211125152612868](Python测试开发.assets/image-20211125152612868.png)



### 八、Secert Key

对于每个要求修改服务器内容的要求，应该使用一次性token，并存储在cookie里，并且在发送表单数据的同时附上它。在服务器再次接收数据之后，需要比较两个token，并确保它们相等。

随机生成Secret Key：os.urandom(24)



### 九、模板渲染表单

通过wtform表单验证器渲染前端表单

~~~python
@app.route('/register',methods='GET','POST')
def register():
	form = RegisterForm(request.form)
	if request.method.lower() == 'get':
		return render_template('login.html', form=form)
	
	if form.validate():
		return '测试通过'
	
	msg = form.errors
	return render_template('login.html', form=form, msg=msg)
~~~



HTML

~~~html
{{ msg }}
<form method='PSOT' action="{{ url_for('register') }}">
    <table>
        <tr>
        	<td>{{ form.phone.label }}</td>
            <td>{{ form.phone | safe }}</td>
        </tr>
        <tr>
        	<td>{{ form.phone.label }}</td>
            <td>{{ form.phone | safe }}</td>
        </tr>
        <tr>
        	<td>{{ form.phone.label }}</td>
            <td>{{ form.phone | safe }}</td>
        </tr>
    </table>
    {{ form.submit }}
</form>
~~~



Ajax

最好为所有的路由配置SCRF保护

~~~javascript
scrf = SCRFProtect(app)

# 配置可以公用
SECRET_KEY = 'ghfdghoh23rtyergdhfgklerh6856798fgsdfgjhgm'

# 或者独立的
WTF_CSRF_SECRET_KEY = 'this is a csrf'

# 模板
<meta name="csrf-token" content="{{ csrf_token() }}">
# 或者在js里
var csrf_token = "{{ csrf_token() }}"
~~~

注意：最好在渲染的模板里写对应的ajax代码，提取出来获取不到对应的csrf_token





## 八、全局变量

### 一、request

当 Fask 应用处理请求时，它会根据从 WSGI 服务器收到的环境创建一个Request对象。因为 工作者（取決于服务器的线程，进程或协程）一次只能处理一个请求，所以在该请求期间请求数据可被认为是该工作者的全局数据。Flask对此使用术语“本地情境”



### 二、请求钩子

* 又叫做“中间件”，请求上下文

在客户端和服务器交互的过程中，有些准备工作或扫尾工作需要处理，比如：

- 在请求开始时，建立数据库连接；
- 在请求开始时，根据需求进行权限校验；
- 在请求结束时，指定数据的交互格式；

为了让每个视图函数避免编写重复功能的代码，Flask提供了通用设施的功能，即请求钩子。请求钩子是通过装饰器的形式实现，Flask支持如下四种请求钩子：

- before_first_request:在处理第一个请求前执行
- before_request:在每次请求前执行,在该装饰函数中,一旦return,视图函数不再执行
  - 注意：before_request如果返回了值，对应的视图函数就不会再执行了，直接返回对应的值。
  - 一个视图函数可以定义多个before_request，并且根据before_request函数的上下位置来决定先后执行顺序。
- after_request:如果没有抛出错误，在每次请求后执行
  - 接受一个参数：视图函数作出的响应
  - 在此函数中可以对响应值,在返回之前做最后一步处理,再返回
  - 如果视图函数报错后，此函数将不再执行
- teardown_request：在每次请求后执行
  - 接受一个参数:用来接收错误信息
  - teardown_request在每次请求中总是会执行，而且无论视图函数是否执行成功



```python
from flask import Flask
from flask import abort

app = Flask(__name__)

# 在第一次请求之前调用，可以在此方法内部做一些初始化操作
@app.before_first_request
def before_first_request():
    print("before_first_request")


# 在每次请求之前调用，这时候已经有请求了，可能在这个方法里面做请求的校验
# 如果请求的校验不成功，可以直接在此方法中进行响应，直接return之后那么就不会执行后面的视图函数
@app.before_request
def before_request():
    print("before_request")
    # if 请求不符合条件:
    #     return "laowang"

# 在执行完视图函数之后会调用，并且会把视图函数所生成的响应传入,可以在此方法中对响应做最后一步统一的处理
@app.after_request
def after_request(response):
    print("after_request")
    response.headers["Content-Type"] = "application/json"
    return response

# 请每一次请求之后都会调用，会接受一个参数，参数是服务器出现的错误信息
@app.teardown_request
def teardown_request(e):
    print("teardown_request")

@app.route('/')
def index():
    return 'index'

if __name__ == '__main__':
    app.run(debug=True)
```

- 在第1次请求时的打印：

```python
before_first_request
before_request
after_request
teardown_request
```

- 在第2,3,..n次请求时的打印：

```
before_request
after_request
teardown_request
```



#### before_request

* 每次访问前接口，此before_request函数都需要执行

情节1、运行需要某段时间的统计数据，不好去改视图函数：

~~~python
@app.before_request
	def get_url():
		print(“统计访问该网址的用户“)
~~~



情节2、验证用户

~~~python
@app.berfore_request
def get_url():
	user = request.args.get('sign')
	if user is None:
		abort(401)
	g.user = user
~~~



情节3、请求时间验证

~~~python
@app.berfore_request
def get_url():
	ts = request.args.get('ts')
	if int(time-time)-ts>5:
		abort(412)
~~~



集中注册



#### after_request

* 场景：封装响应信息
* 常用来接收视图函数返回的**响应体response**
* 当视图函数执行失败，此after_request函数就不会再执行

~~~
@app.after_request
# 组装响应对象
# 当前面出错了这里不会执行
def after(response):
	print('after', request.url)
	response.headers['you'] = 'love'
	return response
~~~

* response 参数必须有
* return的必须是一个Response对象
* 通常用来修改响应
* 如果视图函数出现报错，after_requst则不会发生调用



#### teardown_request

* 常用来接收视图函数返回的**错误信息error**
* 无论视图函数是否执行成功，teardown_request函数都会执行

~~~
@app.teardown_request
def teardown_request(exception):
	print('teart')
	request.url
~~~

* 通常用来释放资源，比如数据库链接
* 不管视图函数有没有发生错误，teardown_request函数都会发生调用





###  三、g变量

* 主要用在同一个请求中共享数据。g变量可以在同一个请求，不同的组件（视图函数）中传递使用。
* g对象是专门用来保存用户数据的
* g对象在一次请求中的所有的代码的地方，都是可以使用的（一次请求可以理解为刷新一次页面）
* g对象发送第二次请求时，便会失效

1、验证用户信息

~~~python
@app.before_request
def get_user():
    sign = request.args.get('user')
    if sign != 'liufei':
        abort(401)
    else:
        a = sign+'md5'  # 相当于用户的token
        g.user = a  # 存储一个key='user',value='a'到全局变量g中

@app.route('/', methods=['GET', 'POST'])
def index():
    print(g.user)  # 调用g全局变量中的值
    return 'Hello world'


if __name__ == '__main__':
    app.run(debug=True)
~~~



2、连接数据库的例子

~~~python
def connect_to_database():
	conn = pymysql.connect(host='localhost', user='root', password='',db='hess', charset='utf8mb4')
	return conn.cursor()
	
@app.before_request
def get_db():
	if 'db' not in g:
		g.db = connect_to_database()

@app.teardown_request
def teardown_db(exception):
	db = g.pop('db', None)
	if db is not None:
		db.close()
        
@app.route('/register', methods=['GET', 'POST'])
def register():
	g.db.execute('SELECT * FROM user_info;')
	a = g.db.fetchall()
	print(a)
~~~



### 四、session

* session和g的最大对象区别是，session对象是可以跨request的，只要session还未失效，不同的request的请求会获取到同一个session，但是g对象不是，g对象不需要管过期时间，请求一次就g对象就改变了一次，或者重新赋值了一次

#### 概念解释

 session 是基于cookie实现， 保存在服务端的键值对（形式为 {随机字符串：‘xxxxxx’}）, 同时在浏览器中的cookie中也对应一相同的随机字符串，用来再次请求的 时候验证；

flask中的session是基于cookie的。

#### 设置session

* 配置SECRET_KEY
  * 因为flask的session是通过加密之后放到了cookie中。所以有加密就有密钥用于解密，所以，只要用到了flask的session模块就一定要配置“SECRET_KEY”这个全局宏。一般设置为24位的字符。

* 操作session
  * 设置session：`session['key'] = value`
  * 获取session：result =  `session.get('key')`，如果内容不存在，将返回None（推荐用法）



~~~python
from flask import Flask, request, session

app = Flask(__name__)
# 必须要设置secret_key
app.config['SECERT_KEY']=os.urandom(24)

@app.route('/')
def home():
    if not session.get('user'):
        return '你没有登录'
    return '这是首页'

@app.route('/login')
def login():
    username=request.args.get("username")
    pwd = request.args.get('pwd')
    if username and pwd:
        session['user'] = username
        return '登录成功'
    return '没有登录'

@app.route('/logout')
def logout():
    session.pop('user', None)  # 或者session['user']=False
    return '退出'
~~~



#### 设置session相关的配置项

##### 1、有效时间

使用场景：登录网页界面，下面有一个“记住我”选项，如果点击了则设置session的有效期长一点。就是设置这个

* 如果没有指定session的过期时间，**那么默认是浏览器关闭后就自动结束**
* 如果设置了session的permanent属性为True，那么过期时间默认是31天。



**先进的配置有效期的方法**：（比如配置7天有效）

- 1.引入包：`from datetime import timedelta`
- 2.配置有效期限：`app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(days=7) # 配置7天有效`
- 3.设置：`session.permanent = True`



##### 2、session名称

* ![image-20211203152237064](Python测试开发.assets/image-20211203152237064.png)

```
"PERMANENT_SESSION_LIFETIME": timedelta(days=31),
"SESSION_COOKIE_NAME": "session",
```



#### session工作流程

![image-20211203150459263](Python测试开发.assets/image-20211203150459263.png)

* 浏览器访问服务器，服务端设置session，并且返回一个sessionID给浏览器，浏览器保存sessionID，再次访问服务器时携带此sessionID， 服务器拿到sessionID与数据库中的session进行比对，通过鉴权。

* session保存在服务器中，浏览器中存储的仅为sessionID。



cookie

~~~
response = make_response('登录成功')
response.set_cookie('current_time', time.stftime('%Y-%M-%D-%H'))
~~~



~~~
request.cookies.get('current_time')
~~~



SecureCookieSessionInterface 和 SecureCookieSession

flask默认提供的session功能很简单，满足了基本的功能。但是我们看到session的数据都保存在客户端的cookie中，这里这有用户名还好，如果有一些私密的数据（比如密码、账户），就会造成严重的安全问题。可以考虑使用flask-session这个第三方的库，它把数据保存在服务端（本地文件、redis、memcached），客户端只拿到一个sessionid。

session主要是用来在不同的请求之间保存信息，最常见的应用就是登录功能。虽然直接通过session自己也可以写出来不错的登录功能，但是在实际的项目中可以考虑flask-login第三方的插件，方便我们的开发。





### 五、current_app

Flask应用对象app具有诸如config之类的属性，这些属性对于在视图或者在命令行调试中访问很有用。但是，在项目中的模块内导入app实例容易导致循环导入问题。

Flask通过应用情景解决了这个问题，不是直接引用一个app，而是使用current_app代理，该代理执行处理当前活动的应用，在其他文件内直接导入from flask import current_app，然后通过current_app.config就可以直接访问app本身的资源属性。 



应用情景是什么？上下文，在上下文中访问某些变量才有意义，在上下文外面是没有意义的。

~~~
from flask import Flask

app = Flask(__name__)

import d3_current_app_view

~~~







## 九、数据库和模型

### 一、sqlite的使用

#### 一、sqlite介绍

SQLite是一种嵌入式数据库，它的数据库就是一个文件。

~~~
'''SQLite数据库是一款非常小巧的嵌入式开源数据库软件，也就是说
没有独立的维护进程，所有的维护都来自于程序本身。
在python中，使用sqlite3创建数据库的连接，当我们指定的数据库文件不存在的时候
连接对象会自动创建数据库文件；如果数据库文件已经存在，则连接对象不会再创建
数据库文件，而是直接打开该数据库文件。
    连接对象可以是硬盘上面的数据库文件，也可以是建立在内存中的，在内存中的数据库
    执行完任何操作后，都不需要提交事务的(commit)

    创建在硬盘上面： conn = sqlite3.connect('c:\\test\\test.db')
    创建在内存上面： conn = sqlite3.connect('"memory:')

    下面我们一硬盘上面创建数据库文件为例来具体说明：
    conn = sqlite3.connect('c:\\test\\hongten.db')
    其中conn对象是数据库链接对象，而对于数据库链接对象来说，具有以下操作：

        commit()            --事务提交
        rollback()          --事务回滚
        close()             --关闭一个数据库链接
        cursor()            --创建一个游标

    cu = conn.cursor()
    这样我们就创建了一个游标对象：cu
    在sqlite3中，所有sql语句的执行都要在游标对象的参与下完成
    对于游标对象cu，具有以下具体操作：

        execute()           --执行一条sql语句
        executemany()       --执行多条sql语句
        close()             --游标关闭
        fetchone()          --从结果中取出一条记录
        fetchmany()         --从结果中取出多条记录
        fetchall()          --从结果中取出所有记录
        scroll()            --游标滚动

'''
~~~



#### 二、 sqlite操作

##### 1、链接

~~~python
@app.before_request
def db():
    c = sqlite3.connect(r'd:\test.db')
    g.db = c
    g.c = c.cursor()

@app.teardown_request
def teardown_request(exception):
    db = getattr(g, 'db', None)
    if db is not None:
        db.close()
~~~



##### 2、初始化数据库

~~~python
@app.route('/', methods=['GET', 'POST'])
def index():
    q = """CREAT TABLE project (ID INT PRIMARY   NOT NULL
                                NAME    CHAR(50)    NOT NULL
                                DESC    CHAR(500);"""
    g.c.execute(q)
    g.db.commit()
    q = f'insert into project (ID,NAME) values (123, "yu");'
    g.c.execute(q)
    g.db.commit()
    return 'hello'
~~~



##### 3、查询数据库

~~~python
@app.route('/s', methods=['GET', 'POST'])
def s():
    g.c.execute('select * from project;')
    print(g.c.fetchall())
    return 's'
~~~



#### 三、sqlite的优势

* 进程访问，不需要通过端口网络
* 支持主流功能
* python自带
* 就是一个文件，备份和迁移很方便



### 二、原生sql



#### 1、数据库引擎

~~~python
def connect_to_database():
    conn = pymysql.connect(host='localhost',
                           user='root',
                           password='123456',
                           db='lemon_tester',
                           charset='utf8mb4')
    return conn.cursor()

@app.route('/')
def index():
    db = connect_to_database()
    db.execute('SELECT * FROM project_info;')
    res = db.fetchall()
    print(res)
    return 'hello'
~~~



#### 2、封装sql语句

~~~python
def connect_to_database():
    pass

class DB():
    def __init__(self):
        self.conn = connect_to_database()

    def query(self, sql):
        self.conn.execute(sql)

    def close(self):
        self.close()

class Project(DB):
    table = 'project_info'

    def list_all(self):
        self.query(f'SELECT * FROM {self.table}')
        res = self.conn.fetchall()
        return res

    def get_by_id(self, id):
        self.query(f'SELECT * FROM {self.table} WHERE id={id}')
        res = self.conn.fetone()
        return res
~~~

* 将sql封装完成后，直接在视图函数中调用即可





### 三、ORM



#### 一、什么是ORM

* 将pysql和sql语句封装成对象
* ORM框架是模型的框架

##### 1、什么是模型:

ORM框架（全称:Object Relational Mapping,又称持久化框架）是模型的框架,首先要了解模型，模型是根据数据库中表结构而创建出来的类（类化）,数据库中的每张表对应到编程语言中就是一个class, 表中的每个列对应到编程语言中就是class中的一个属性.



##### 2、ORM的三种映射

* 数据表(Table)到编程类(Class)的映射
* 数据类型的映射：数据库中表的字段以及数据类型 对应到 编程语言中就是类的属性及其数据类型



##### 3、关系映射

* 将数据库中表与表之间的关系 对应到 编程语言中类与类之间的关系上



##### 4、ORM的优点

* 封装了数据库的操作，提升效率
* 省略了庞大的数据访问层，即便不使用sql语句也能完成CRUD操作



##### 5、原生sql和ORM 是两种不同的编程模式

* 原生sql：谁都能看懂，维护成本低，开发效率低

  * 先手工建表，然后根据表结构写代码

  

* ORM：sql直接封装好了，可读性高，开发效率高。

  * 避免sql注入
  * 使用原生sql，各个不同的数据需要写不同的查询语言。使用ORM模型不需要。
  * 先写代码定义模型，通过代码生成表及表结构。



#### 二、数据库创建步骤

* 0、安装sqlalchemy或者**flask-sqlalchemy**,pip install flask-sqlalchemy
  * http://www.pythondoc.com/flask-sqlalchemy/quickstart.html
* 1、配置数据库：mysql或者sqlite
* 2、定义表结构，设计表
* 3、创建表

##### 1、样例

~~~python
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql+pymysql://root:@localhost:3306/demo'
app.config['SQLALCHEMKY_TRACK_MODIFICATIONS'] = False
db = SQLALchemy(app)

class User(db.Model):  # 创建一个表模型，数据模型继承的类时db.Model
	id = db.Column(db.Integer, primary_key=True)  # 数据类型及列属性直接从db导入
	username = db.Column(db.String(80), unique=True)
	email = db.Column(db.String(120), unique=True)
	
def create_all():  # 调用此方法初始化模型，将表创建到数据库中
	return db.create_all()

create_all()
~~~



##### 2、初始化数据库的三种方式

* 即将代码中的表模型创建出来

1、代码

~~~
app = Flask(__name__)
db = SQLAlchemy(app)

db = SQLAlchemy()

def create_app():
	app = Flask(__name__)
	db.init_app(app)
	return app
	
	# 推入上下文更好
	with app.app_ocntext as ctx:
		db.create_all()
~~~





2、在command创建

~~~shell
set FLASK_APP = run.py

cmd命令行下：flask shell (进入 flask中自带的 shell)
>>>from run import db
>>>db.create_all()  # 此时数据库已经初始化完成

# 数据库已经生成。现在来创建一些用户,目前还没有真正地写入到数据库中
>>>from app import User
>>>one=User('panda', 'panda@qq.com')
>>>two=User('cat','cat@qq.com')

# 将创建的用户写入数据库
>>>db.session.add(one)
>>>db.session.add(two)
>>>db.session.commit()

# 访问数据库中的数据也是十分简单的:
>>> users = User.query.all()  # 获取数据库中表的所有数据
[<User u'panda'>, <User u'cat'>]
>>> admin = User.query.filter_by(username='panda').first()
<User u'cat'>
~~~





3、通过migrate创建

* pip install flask-migrate

* 迁移的时候更方便
* 动态修改数据库结构



~~~
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql+pymysql://root:@localhost:3306/demo'
db = SQLALchemy(app)
migrate = Migrate(app, db)

# 全部在cmd命令行下执行
set FLASK_APP = run.py
flask db init
flask db migrate  # 生成脚本
flask db upgrade  # 更新到数据库
flask db downgrade  # 退回

~~~



##### 3、配置参数

**app.config['参数名称'] = 值**

| 参数名                      | 作用                                                         |
| --------------------------- | ------------------------------------------------------------ |
| `SQLALCHEMY_DATABASE_URI`   | 用于连接数据的数据库。例如：`sqlite:tmp/test.db``mysql://username:password@server/db` |
| `SQLALCHEMY_BINDS`          | 一个映射绑定 (bind) 键到 SQLAlchemy 连接 URIs 的字典。 更多的信息请参阅 [*绑定多个数据库*](http://www.pythondoc.com/flask-sqlalchemy/binds.html#binds)。 |
| `SQLALCHEMY_ECHO`           | 如果设置成 True，SQLAlchemy 将会记录所有 发到标准输出(stderr)的语句，这对调试很有帮助。 |
| `SQLALCHEMY_RECORD_QUERIES` | 可以用于显式地禁用或者启用查询记录。查询记录 在调试或者测试模式下自动启用。更多信息请参阅 `get_debug_queries()`。 |
| `SQLALCHEMY_NATIVE_UNICODE` | 可以用于显式地禁用支持原生的 unicode。这是 某些数据库适配器必须的（像在 Ubuntu 某些版本上的 PostgreSQL），当使用不合适的指定无编码的数据库 默认值时。 |
| `SQLALCHEMY_POOL_SIZE`      | 数据库连接池的大小。默认是数据库引擎的默认值 （通常是 5）。  |
| `SQLALCHEMY_POOL_TIMEOUT`   | 指定数据库连接池的超时时间。默认是 10。                      |





##### 4、连接 URI 格式

完整连接 URI 格式列表请跳转到 SQLAlchemy 下面的文档([支持的数据库](http://www.sqlalchemy.org/docs/core/engines.html))。这里展示了一些常见的连接字符串。

SQLAlchemy 把一个引擎的源表示为一个连同设定引擎选项的可选字符串参数的 URI。URI 的形式是:

```
dialect+driver://username:password@host:port/database
```

该字符串中的许多部分是可选的。如果没有指定驱动器，会选择默认的（确保在这种情况下 **不**包含 `+` ）。

Postgres数据库:

```
postgresql://scott:tiger@localhost/mydatabase
```

MySQL数据库:

```
mysql://scott:tiger@localhost/mydatabase
```

Oracle数据库:

```
oracle://scott:tiger@127.0.0.1:1521/sidname
```

SQLite (注意开头的斜线)数据库:

* 在Windows系统中，开头需要四个斜线
* 在Linux系统中，开头需要三个斜线

```
sqlite:////absolute/path/to/foo.db
sqlite:///absolute/path/to/foo.db
```



##### 5、多个数据库绑定

http://www.pythondoc.com/flask-sqlalchemy/binds.html

1、配置声明

下面的配置声明了三个数据库连接。特殊的默认值和另外两个分别名为 users`（用于用户）和 `appmeta 连接到一个提供只读访问应用内部数据的 sqlite 数据库）:

~~~python
app.config['SQLALCHEMY_DATABASE_URI'] ='sqlite:////d:/demo1.db'
app.config['SQLALCHEMY_BINDS'] = {
	'users':   'sqlite:////d:/demo1.db',
	'main':    'mysql+pymysql://root:@localhost:3306/demo'
}

~~~



先在config配置项声明几个数据库的链接



2、模型绑定

在Models定义的时候不指定就使用默认的数据库引擎(`SQLALCHEMY_DATABASE_URI` 配置值)，指定的话就用指定的数据库引擎。

* 数据库引擎简单来说就是一个"数据库发动机"。当你访问数据库时，不管是手工访问，还是程序访问，都不是直接读写数据库文件，而是 通过数据库引擎去访问数据库文件。以关系型数据库为例，你发SQL语句给数据库引擎， 数据库引擎解释SQL语句，提取出你需要的数据返回给你。因此，对访问者来说，数据库引擎就是SQL语句的解释器。
  

~~~python
class User(db.Model):
	__bind_key__ = 'users'
~~~

然后再在数据模型中指定用哪个数据库（即进行绑定），然后我们在初始化数据库创建数据模型的时候就会自动去找到这个数据库进行创建。

在数据模型类中指定这个绑定binds，当在初始化或者说创建这个数据库时则只能通过这个绑定binds来创建数据库。



3、运行

~~~python
with app.app_context() as ctx:
	ctx.push()
	user = User(username='yuz', email = 'sofo')
	db.session.add(user)
	db.session.commit()
~~~



#### 三、数据库模型定义的参数说明

在 ORM 中, 模型一般是一个 Python 类, 类对应表，类中的属性对应数据库中的表的字段。Flaks-SQLAlchemy 创建的数据库实例为模型提供了一个基类以及一些列辅助类和辅助函数, 可用于定义模型的结构。

https://www.cnblogs.com/jinjidedale/p/6180262.html

* db.Model  # 模型类class继承db.Model，用来创建模型,

* db.Column  # 创建模型属性.

##### 模型属性的类型 :

| 类型名       | Python类型         | 说明                                                  |
| ------------ | ------------------ | ----------------------------------------------------- |
| Integer      | int                | 普通整数，一般是 32 位                                |
| SmallInteger | int                | 取值范围小的整数，一般是 16 位                        |
| Big Integer  | int 或 long        | 不限制精度的整数                                      |
| Float        | float              | 浮点数                                                |
| Numeric      | decimal.Decimal    | 定点数                                                |
| String(size) | str                | 变长字符串，有长度限制                                |
| Text         | str                | 变长字符串，对较长或不限长度的字符串做了优化          |
| Unicode      | unicode            | 变长 Unicode 字符串                                   |
| Unicode Text | unicode            | 变长 Unicode 字符串，对较长或不限长度的字符串做了优化 |
| Boolean      | bool               | 布尔值                                                |
| Date         | datetime.date      | 日期                                                  |
| Time         | datetime.time      | 时间                                                  |
| DateTime     | datetime.datetime  | 日期和时间                                            |
| Interval     | datetime.timedelta | 时间间隔                                              |
| Enum         | str                | 一组字符串                                            |
| PickleType   | 任何 Python 对象   | 自动使用 Pickle 序列化                                |
| LargeBinary  | str                | 二进制文件                                            |

##### 常用 SQLAlchemy 列（表中字段）选项

| 选项名                      | 说明                                                         |
| --------------------------- | ------------------------------------------------------------ |
| primary_key                 | 如果设为 True，这列就是表的主键。自增长。                    |
| autoincrement               | 如果设为 True，这列为自增长。主键列不需要设置自增长，默认是自增长的 |
| unique                      | 如果设为 True，这列不允许出现重复的值                        |
| index                       | 如果设为 True，为这列创建索引，提升查询效率。注意不要给多列同时设置索引消耗资源。 |
| nullable                    | 如果设为 True，这列允许使用空值；如果设为 False，这列不允许使用空值 |
| default                     | 为这列定义默认值                                             |
| comment                     | 说明，注释                                                   |
| db.ForeignKey('project.id') |                                                              |

Flask-SQLAlchemy 要求每个模型都要定义主键, 这一列通常命名为 id .



#### 四、数据库操作

##### 1、创建表

~~~python
db.create_all()
~~~



##### 2、插入行

~~~python
from d3_flask_migrate import db
from db_flask_migrate import User

user = User(username='demo')
db.session.add(user)  # 保存到会话
# 添加多个
db.session.add_all([user1, user2])
db.session.commit()		

~~~



##### 3、查询过滤

* ORM 模型中关于查询的相关操作全部封装在Query对象中。

  ```
  from sqlalchemy.orm import Query
  ```



###### 1、所有的all()

~~~python
users = User.query.all()

# 链式调用, 所有的方法返回的都是同一个对象，直到返回的对象不是同一个时停止调用
users = User.query.where().group_by().offset().all()
~~~



###### 2、第一行数据first()

~~~python
users = User.query.first()

~~~



###### 3、get()通过主键去获取

~~~python
# 表中只有一个主键
user = User.query.get(4)  # 表中只有一个主键时，get方法会自动去寻找该主键并匹配

# 如果有多个主键
users = User.query.get((1,5))
users = User.query.get({"id":1, "project_id":3})  # 有多个主键时需要提供字段名
~~~



###### 4、filter_by()

* 用于简单的等值查询，不支持比较运算符。
* 直接使用**属性名=值**

~~~python
admin = User.query.filter_by(username = 'admin').first()
~~~



###### 5、filter()更加复杂的查询

* 支持比较运算符，支持or_、in_等语法。
* 需要通过**类名.属性名**的方式，**类名.属性名==值**。

~~~python
User.query.filter(User.email.endswith('@example.com')).all()
~~~

* filter支持的具体表达式，可以在ColumnOperators源码中查看。

  ~~~
  from sqlalchemy.sql.operators import ColumnOperators
  ~~~

* filter()进行多条件查询
  * 查询用户姓名是阎秀英，并且用户的role_id=3的数据

    ~~~
    u = User.query.filter(User.name=='阎秀英').filter(User.role_id==3).first() 这里用多个filter作为多个条件的选择
    或者
    u = User.query.filter(User.name=='阎秀英', User.role_id==3).first() 用1个filter，多个条件中间用逗号分开，他的效果和使用and_()一样
    或者
    u = User.query.filter(and_(User.name=='阎秀英', User.role_id==3)).first()
    ~~~

    

  * 查询role_id不等于3，并且id大于10的数据

    ~~~
    u = User.query.filter(User.role_id != 3, User.id > 10).all()
    ~~~

    



###### 6、按某种规则对用户排序

~~~
>>> User.query.order_by(User.username.desc()).all()  # 降序排列， 默认order_by()方法升序
[<User u'admin'>, <User u'guest'>, <User u'peter'>]
~~~



###### 7、限制返回的数量

~~~
>>> User.query.order_by(User.username.desc()).limit(1).all()
[<User u'admin']
~~~



##### 4、删除

~~~
db.session.delete(me)
>>> db.session.commit()
~~~



##### 5、first_or_404

没找到就abort()和看异常处理机制配合起来使用



##### 6、数据更新

~~~
user = User()
db.session.add(user)

# 添加多个
db.session.add_all([user1, user2])

db.session.commit()
~~~



#### 五、分页

如何分页

sql实现分页



#### 六、数据库迁移

~~~
flask db init
flask db migrate  # 生成脚本
flask db upgrade  # 更新到数据库
flask db downgrade  # 退回
~~~



#### 七、执行原生SQL语句

* 一般直接执行原生sql语句，常用于比较复杂的sql。

##### 1、db.session.execute()

~~~python
def select():
	with app.app_context() as ctx:
		sql = 'select * from user;'
		a = db.session.execute(sql)
		# a是一个ResultProxy
		# print(a.fetchall())
		# print(a.fetchone())
~~~



用原生sqlalchemy执行sql语句

~~~
def init_sql():
	import sqlalchemy
	
	db_engine = sqlalchemy.create_engine('mysql+pymysql://root:@localhost/weibo', echo=True)
	db_conn = db_engine.connect()
	a = db_conn.execute('select * from user;')
	print(a.fetchall())
~~~



##### 2、原生sql语句的参数化：

~~~python
session = Session(bind=engine)
sql = 'select * from user where name = :name;'
a = session.execute(sql, params={'name':'panda'})
print(a.fetchall())
print(a.fetchone())
~~~







### 四、ORM模型关系



学生表(student)中的gid是学生所在的班级id，是引入了班级表(grade)中的主键id。那么gid就可以作为表student的外键。被引用的表，即表grade是主表;引用外键的表，即表student是从表，两个表是主从关系。表student用gid可以连接表grade中的信息，从而建立了两个表数据之间的连接。

引入外键后，外键列只能插入参照列存在的值，参照列被参照的值不能被删除，这就保证了数据的参照完整性。



外键：外键是用来再两个表的数据之间建立连接，他可以是一列也可以是多列。一个表中可以有一个或多个外键。

​     一个表的外键可以是空值，若不为空值，则每一个外键值必须等于另外一个表中的主键的某个值。

外键是一个表中的字段，他可以不是本表中的主键，但对应另外一个表的主键，外键的作用是保证数据引用的完整性。





一对多模型关系定义步骤

 建立两个模型 roles 和 user 两者关系是一对多

 在user(多的一方)中添加roles(一方)的id作为外键, 两者形成关联

如果两者之间要实现一对多和多对一的查询, 就在 roles(一方)当中建立一对多的对象, 使用relationship(第一个参数是多方模型类名(user), backref="多对一的查询对象") : users = db.relationship(''user'', backref='''role' , lazy='"动态手动加载"')



backref



~~~python
class Project(db.Model):
	id = db.column(db.Integer, primary_key = True)
	modules = db.relationship('Module', backref='project')
	
class Module(db.Model):
	id = db.Column(db.Integer, primary_key=True)
	project_id = db.Column(db.Integer, db.ForeignKey('porject.id'))
~~~



back_populates

显示的说明两个模型表之间的关系

~~~python
class Project(db.Model):
	id = db.column(db.Integer, primary_key = True)
	# 这里的modules和Model里面的back_populaters='modules'相等
	modules = db.relationship('Module', back_populates='project')
	
class Module(db.Model):
	id = db.Column(db.Integer, primary_key=True)
	# 这里的project和Project里面的back_populaters='project'相等
	project = db.relationship('Module', back_populates='modules')
~~~





backref    VS     back_populates

back_populates需要双向显示说明，backref只需要指明一边隐式声明

back_populates更麻烦，backref更简单

back_populates更具有可读性，能够很快知道各个表之间的关系





一对一关系



~~~python
class Project(db.Model):
	id = db.column(db.Integer, primary_key = True)
	# 这里的modules和Model里面的back_populaters='modules'相等
	modules = db.relationship('Module', back_populates='project', uselist=False)
	
class Module(db.Model):
	id = db.Column(db.Integer, primary_key=True)
	# 这里的project和Project里面的back_populaters='project'相等
	project = db.relationship('Module', back_populates='modules', uselist=False)
~~~



多对多关系

适用场景

关系表只存储两个关联表的id作为外键，没有其他信息

关联表并不能作为模型操作

~~~
xuanke = db.Table('xuanke', db.Column('user_id', db.Integer, db.ForeignKey('user.id')),
							db.Column('subject_id', db.Integer, db.ForeignKey('subject.id')))
							
class User(db.Model):
	id = db.Column(db.Integer, primary_key=True)
	subjects = db.relationship('Subject', secondary=xuanke, backref=db.backref('users', lazy='dynamic'))

class Subject(db.Model):
	id = db.Column(db.Integer, primary_key=True)
~~~



获取关系

user=User.query.get(1)

kecheng=user.subjects



多对多关系需要获取额外内容

适用场景

关系表除了存储两个关联表的id还有其他信息，比如选课时间、分数。

关联表并不能作为模型操作

~~~
class Xuanke(db.Model):
	student_id = db.Column('student_id', db.Integer, db.ForeignKey('user.id'), primary_key=True)
	subject_id = db.Column('subject_id', db.Integer,db.ForeignKey('subject.id'), primary_key=True)
	
class User(db.Model):
	id = db.Column(db.Integer, primary_key=True)
	name = db.Column(db.String(20), nullable=False)
	subjects = db.relationship('Xuanke', backref='student')
~~~



获取关系

~~~
user = User.query.get(1)
# 获取选课
xuanke=user.subjects
# 获取课程
for ke in xuanke:
	print(ke.subject)
~~~





自引用关系

~~~
class Follower(db.Model):
	fensi_id = db.Column(db.Integer, db.ForeignKey('user.id'), primary_key=True)
	guanzhuzhe_id = db.Column(db.Integer, db.ForeignKey('user.id'), primary_key=True)

class User(db.Model):
	id = db.Column(db.Integer, primary_key=True)
	name = db.Column(db.String(20), nullable=False)
	sbujects = db.relationship('Xuanke', back_populates='student')
	fensis=db.relationship('Follower', foreign_keys = [Follower.guanzhuzhe_id], backref='guanzhuzhe')
	guanzhuzhes = db.relationship('Follower', foreign_keys=[Follower.fensi_id], backref='fensi')
~~~

注意：不要使用back_populates，会出错









































